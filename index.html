<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Tilt Tower</title>
<meta name="description" content="„Çπ„Éû„Éõ„ÇíÂÇæ„Åë„Å¶„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ©ç„ÇÅÔºÅ">
<meta name="theme-color" content="#0a0a2e" id="metaThemeColor">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.svg">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  /* ===== CSS Variables: Dark Theme (default) ===== */
  :root {
    --bg-primary: #0a0a2e;
    --bg-secondary: #1a1a4e;
    --bg-overlay: rgba(10, 10, 46, 0.94);
    --text-primary: #fff;
    --text-muted: rgba(255,255,255,0.5);
    --accent: #4facfe;
    --accent-glow: rgba(79,172,254,0.4);
    --card-border: rgba(255,255,255,0.08);
    --card-bg: rgba(255,255,255,0.05);
    --input-bg: rgba(255,255,255,0.1);
    --input-border: rgba(79,172,254,0.4);
    --toggle-off: rgba(255,255,255,0.15);
    --coin-gold: #FFD700;
    --coin-glow: rgba(255,215,0,0.4);
  }

  /* ===== Light Theme ===== */
  html.light {
    --bg-primary: #f0f4f8;
    --bg-secondary: #dce3ed;
    --bg-overlay: rgba(240,244,248,0.96);
    --text-primary: #1a1a2e;
    --text-muted: rgba(26,26,46,0.5);
    --accent: #2b7cff;
    --accent-glow: rgba(43,124,255,0.3);
    --card-border: rgba(0,0,0,0.1);
    --card-bg: rgba(0,0,0,0.04);
    --input-bg: rgba(0,0,0,0.06);
    --input-border: rgba(43,124,255,0.4);
    --toggle-off: rgba(0,0,0,0.12);
    --coin-gold: #DAA520;
    --coin-glow: rgba(218,165,32,0.3);
  }

  /* ===== Base ===== */
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    touch-action: none;
    background: var(--bg-primary);
    font-family: 'Segoe UI', system-ui, sans-serif;
    color: var(--text-primary);
  }
  canvas {
    display: block;
    width: 100%; height: 100%;
  }

  /* ===== Screens ===== */
  .screen {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 10;
    transition: opacity 0.4s;
  }
  .screen.hidden { opacity: 0; pointer-events: none; }

  /* ===== Buttons ===== */
  .btn {
    background: var(--accent);
    border: none; color: #fff;
    padding: 14px 48px; border-radius: 12px;
    font-size: 1.15rem; font-weight: bold;
    cursor: pointer;
    letter-spacing: 1px;
    box-shadow: 0 4px 16px var(--accent-glow);
    transition: background 0.2s, transform 0.1s;
  }
  .btn:active { transform: scale(0.95); }
  .btn-share {
    background: #2ecc71;
    border: none; color: #fff;
    padding: 14px 40px; border-radius: 12px;
    font-size: 1.1rem; font-weight: bold;
    cursor: pointer; margin-bottom: 10px;
    letter-spacing: 1px;
    box-shadow: 0 4px 16px rgba(46,204,113,0.3);
    transition: transform 0.1s;
  }
  .btn-share:active { transform: scale(0.95); }

  /* ===== Start Screen ===== */
  #startScreen { background: var(--bg-primary); }
  #startScreen h1 {
    font-size: 2.8rem; color: var(--text-primary);
    text-shadow: 0 0 24px var(--accent-glow);
    margin-bottom: 4px; letter-spacing: -1px;
  }
  #startScreen .subtitle {
    color: var(--text-muted); font-size: 0.95rem;
    margin-bottom: 2rem;
  }
  .start-best {
    color: var(--text-muted); font-size: 1rem;
    font-family: 'Courier New', monospace;
    margin-bottom: 0.3rem;
  }
  .start-greeting {
    color: var(--text-muted); font-size: 0.95rem;
    margin-bottom: 1.5rem;
  }
  .start-greeting .name { color: var(--text-primary); font-weight: 600; }

  /* START button pulse */
  @keyframes btnPulse {
    0%, 100% { box-shadow: 0 4px 16px var(--accent-glow); }
    50% { box-shadow: 0 4px 30px var(--accent-glow), 0 0 60px var(--accent-glow); }
  }
  #startBtn { animation: btnPulse 2s ease-in-out infinite; }

  /* Settings gear button */
  #settingsBtn {
    position: absolute; top: 14px; right: 14px;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    color: var(--text-muted); font-size: 0.85rem;
    width: 42px; height: 42px; border-radius: 10px;
    cursor: pointer; display: flex;
    align-items: center; justify-content: center;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    transition: background 0.2s;
  }
  #settingsBtn:active { background: var(--input-bg); }

  /* ===== Game Over Screen ===== */
  #gameOverScreen { background: var(--bg-overlay); backdrop-filter: blur(4px); }
  #gameOverScreen h2 {
    font-size: 2rem; color: #ffe066;
    margin-bottom: 0.3rem; letter-spacing: 2px;
  }
  #gameOverScreen .score-display {
    font-size: 3.2rem; color: var(--accent);
    font-weight: bold; margin: 0.5rem 0;
    font-family: 'Courier New', monospace;
  }
  #gameOverScreen .best-score {
    color: var(--text-muted); font-size: 0.95rem;
    margin-bottom: 0.3rem;
  }
  #gameOverScreen .height-display {
    color: var(--text-muted); font-size: 1rem;
    margin-bottom: 0.3rem;
  }
  #peakMoment {
    color: #ffe066; font-size: 0.9rem;
    font-weight: bold; margin-bottom: 1.2rem;
    min-height: 1.2em;
  }
  /* NEW BEST badge */
  @keyframes newBestPulse {
    0%, 100% { transform: scale(1); text-shadow: 0 0 8px rgba(255,224,102,0.4); }
    50% { transform: scale(1.08); text-shadow: 0 0 20px rgba(255,224,102,0.8); }
  }
  #newBestBadge {
    color: #ffe066; font-size: 1.4rem; font-weight: bold;
    letter-spacing: 2px;
    animation: newBestPulse 1s ease-in-out infinite;
    margin-bottom: 0.3rem;
    display: none;
  }
  #newBestBadge.show { display: block; }

  /* ===== HUD ===== */
  #hud {
    position: fixed; top: 0; left: 0; right: 0;
    padding: 14px 18px;
    display: flex; justify-content: space-between;
    z-index: 5; color: var(--text-primary);
    pointer-events: none;
  }
  #hud .label {
    opacity: 0.4; font-size: 0.65rem;
    text-transform: uppercase; letter-spacing: 1px;
  }
  #hud .value {
    font-weight: bold; font-size: 1.3rem;
    font-family: 'Courier New', monospace;
  }

  /* ===== Combo Gauge ===== */
  #comboGauge {
    position: fixed; top: 52px; left: 18px; right: 18px;
    z-index: 5; pointer-events: none;
    opacity: 0; transition: opacity 0.3s;
  }
  #comboGauge.show { opacity: 1; }
  #comboTrack {
    height: 3px;
    background: rgba(255,255,255,0.06);
    border-radius: 2px; overflow: hidden;
  }
  #comboFill {
    height: 100%; border-radius: 2px;
    width: 0%; background: var(--accent);
    transition: width 0.3s, background 0.3s;
  }
  #comboLabel {
    font-size: 0.6rem; color: var(--text-muted);
    text-align: right; margin-top: 2px;
    letter-spacing: 1px;
  }

  /* ===== Tilt Indicator ===== */
  #tiltIndicator {
    position: fixed; bottom: 16px; left: 50%;
    transform: translateX(-50%);
    z-index: 5; pointer-events: none;
    display: flex; align-items: center; gap: 6px;
    color: var(--text-muted); font-size: 0.7rem;
  }
  #tiltBar {
    width: 100px; height: 4px;
    background: rgba(255,255,255,0.06);
    border-radius: 2px; position: relative;
  }
  #tiltDot {
    width: 10px; height: 10px;
    background: var(--accent); border-radius: 50%;
    position: absolute; top: -3px;
    left: 50%; transform: translateX(-50%);
    transition: left 0.1s;
    box-shadow: 0 0 6px var(--accent-glow);
  }

  /* ===== Permission Prompt ===== */
  #permissionPrompt {
    position: fixed; inset: 0;
    background: var(--bg-overlay);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 20; text-align: center;
    padding: 2rem;
  }
  #permissionPrompt.hidden { display: none; }
  #permissionPrompt p {
    margin-bottom: 1.5rem; line-height: 1.6;
    color: var(--text-muted);
  }
  #permissionPrompt .perm-title {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 1rem; color: var(--text-primary);
  }

  /* ===== Name Prompt ===== */
  #namePrompt {
    position: fixed; inset: 0;
    background: var(--bg-overlay);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 20; text-align: center;
    padding: 2rem;
  }
  #namePrompt.hidden { display: none; }
  #namePrompt .np-title {
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 0.5rem;
  }
  #namePrompt p {
    margin-bottom: 1.5rem; line-height: 1.6;
    color: var(--text-muted);
  }
  #namePrompt input {
    width: 220px; padding: 12px 16px;
    border: 1px solid var(--input-border);
    border-radius: 10px; background: var(--input-bg);
    color: var(--text-primary); font-size: 1.1rem;
    text-align: center; outline: none; margin-bottom: 1.5rem;
  }
  #namePrompt input::placeholder { color: var(--text-muted); }
  #namePrompt input:focus { border-color: var(--accent); }

  /* ===== Settings Screen ===== */
  #settingsScreen {
    position: fixed; inset: 0;
    background: var(--bg-overlay);
    backdrop-filter: blur(8px);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 20; text-align: center;
    padding: 2rem;
    overflow-y: auto;
  }
  #settingsScreen.hidden { display: none; }
  #settingsScreen h2 {
    font-size: 1.5rem; margin-bottom: 1.5rem;
    color: var(--text-primary); letter-spacing: 1px;
  }
  .setting-card {
    width: 270px;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 12px;
    padding: 12px 16px;
    margin-bottom: 10px;
    text-align: left;
  }
  .setting-card .s-label {
    font-size: 0.7rem; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 1px;
    margin-bottom: 8px;
  }
  .setting-card input[type="text"] {
    width: 100%; padding: 8px 12px;
    border: 1px solid var(--card-border);
    border-radius: 8px; background: var(--input-bg);
    color: var(--text-primary); font-size: 0.95rem;
    outline: none;
  }
  .setting-card input[type="text"]:focus { border-color: var(--accent); }
  .setting-card input[type="range"] {
    width: 100%; accent-color: var(--accent);
  }
  .range-display {
    text-align: center; font-size: 0.8rem;
    color: var(--text-muted); margin-top: 3px;
  }
  /* Theme selector */
  .theme-selector { display: flex; gap: 6px; }
  .theme-opt {
    flex: 1; padding: 7px 0;
    border-radius: 8px;
    border: 1px solid var(--card-border);
    background: transparent;
    color: var(--text-muted);
    font-size: 0.8rem; cursor: pointer;
    text-align: center;
    transition: all 0.2s;
  }
  .theme-opt.active {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
  }
  /* Toggle row */
  .s-toggle-row {
    display: flex; align-items: center;
    justify-content: space-between;
  }
  .s-toggle-label { color: var(--text-primary); font-size: 0.9rem; }
  .toggle {
    position: relative; width: 48px; height: 26px;
    background: var(--toggle-off); border-radius: 13px;
    cursor: pointer; transition: background 0.3s;
    flex-shrink: 0;
  }
  .toggle.on { background: var(--accent); }
  .toggle::after {
    content: ''; position: absolute;
    top: 3px; left: 3px;
    width: 20px; height: 20px;
    background: #fff; border-radius: 50%;
    transition: transform 0.3s;
  }
  .toggle.on::after { transform: translateX(22px); }

  /* ===== Share Toast ===== */
  #shareToast {
    position: fixed; bottom: 60px; left: 50%;
    transform: translateX(-50%);
    background: rgba(46,204,113,0.9);
    color: #fff; padding: 10px 24px;
    border-radius: 12px; font-size: 0.85rem;
    z-index: 30; opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  #shareToast.show { opacity: 1; }

  /* ===== Coin Balance (Start Screen) ===== */
  .start-coins {
    color: var(--coin-gold);
    font-size: 1.1rem;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    margin-bottom: 0.8rem;
    letter-spacing: 1px;
  }

  /* ===== Daily Bonus Card ===== */
  #dailyBonusCard {
    background: var(--card-bg);
    border: 1.5px solid var(--coin-gold);
    border-radius: 14px;
    padding: 14px 18px;
    margin-bottom: 1rem;
    width: 260px;
    text-align: center;
    box-shadow: 0 2px 12px var(--coin-glow);
  }
  #dailyBonusCard.hidden { display: none; }
  .daily-title {
    font-size: 0.85rem;
    font-weight: bold;
    color: var(--coin-gold);
    letter-spacing: 1px;
    margin-bottom: 8px;
  }
  .daily-dots {
    display: flex;
    justify-content: center;
    gap: 6px;
    margin-bottom: 8px;
  }
  .daily-dot {
    width: 24px; height: 24px;
    border-radius: 50%;
    border: 2px solid var(--card-border);
    background: var(--card-bg);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.55rem;
    color: var(--text-muted);
    transition: all 0.3s;
  }
  .daily-dot.claimed {
    background: var(--coin-gold);
    border-color: var(--coin-gold);
    color: #1a1a2e;
    font-weight: bold;
  }
  .daily-dot.current {
    border-color: var(--coin-gold);
    animation: dailyDotPulse 1.5s ease-in-out infinite;
  }
  @keyframes dailyDotPulse {
    0%, 100% { box-shadow: 0 0 0 0 var(--coin-glow); }
    50% { box-shadow: 0 0 8px 3px var(--coin-glow); }
  }
  .daily-reward {
    font-size: 1.1rem;
    font-weight: bold;
    color: var(--coin-gold);
    margin-bottom: 2px;
  }
  .daily-multiplier {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 8px;
  }
  .daily-claim-btn {
    background: var(--coin-gold);
    border: none;
    color: #1a1a2e;
    padding: 8px 28px;
    border-radius: 10px;
    font-size: 0.95rem;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 2px 10px var(--coin-glow);
    transition: transform 0.1s;
  }
  .daily-claim-btn:active { transform: scale(0.95); }
  .daily-claimed-text {
    font-size: 0.8rem;
    color: var(--text-muted);
  }

  /* ===== Coin Reward (Game Over) ===== */
  #coinReward {
    color: var(--coin-gold);
    font-size: 1.2rem;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    margin-bottom: 0.2rem;
    opacity: 0;
    transform: scale(0.5);
    transition: opacity 0.4s, transform 0.4s;
  }
  #coinReward.show {
    opacity: 1;
    transform: scale(1);
  }
  #streakMultiplier {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.6rem;
    min-height: 1em;
  }

  /* ===== HUD Coins ===== */
  #hudCoins {
    position: fixed;
    top: 48px; right: 18px;
    z-index: 5;
    pointer-events: none;
    color: var(--coin-gold);
    font-size: 0.75rem;
    font-family: 'Courier New', monospace;
    text-align: right;
    opacity: 0.6;
  }

  /* ===== Shop Button (Start Screen) ===== */
  #shopBtn {
    position: absolute; top: 14px; left: 14px;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    color: var(--coin-gold); font-size: 1.1rem;
    width: 42px; height: 42px; border-radius: 10px;
    cursor: pointer; display: flex;
    align-items: center; justify-content: center;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    transition: background 0.2s;
  }
  #shopBtn:active { background: var(--input-bg); }
  .shop-notify-dot {
    position: absolute; top: -2px; right: -2px;
    width: 8px; height: 8px;
    background: #ff4757; border-radius: 50%;
    display: none;
  }
  .shop-notify-dot.show { display: block; }

  /* ===== Ranking Button (Start Screen) ===== */
  #rankingBtn {
    position: absolute; top: 62px; right: 14px;
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    color: var(--text-muted); font-size: 0.85rem;
    width: 42px; height: 42px; border-radius: 10px;
    cursor: pointer; display: flex;
    align-items: center; justify-content: center;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    transition: background 0.2s;
  }
  #rankingBtn:active { background: var(--input-bg); }

  /* ===== Shop Screen ===== */
  #shopScreen {
    position: fixed; inset: 0;
    background: var(--bg-overlay);
    backdrop-filter: blur(8px);
    display: flex; flex-direction: column;
    align-items: center;
    z-index: 20;
    padding: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  #shopScreen.hidden { display: none; }
  .shop-header {
    position: sticky; top: 0;
    width: 100%;
    background: var(--bg-overlay);
    backdrop-filter: blur(12px);
    padding: 14px 18px;
    display: flex; align-items: center;
    justify-content: space-between;
    z-index: 2;
    border-bottom: 1px solid var(--card-border);
  }
  .shop-back-btn {
    background: none; border: none;
    color: var(--text-primary);
    font-size: 1.1rem; cursor: pointer;
    padding: 6px 12px;
  }
  .shop-title {
    font-size: 1.2rem; font-weight: bold;
    color: var(--text-primary);
  }
  .shop-coins {
    color: var(--coin-gold);
    font-weight: bold;
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
  }
  .shop-tabs {
    display: flex; width: 100%;
    border-bottom: 1px solid var(--card-border);
    background: var(--bg-overlay);
    position: sticky; top: 52px;
    z-index: 2;
  }
  .shop-tab {
    flex: 1; padding: 10px 0;
    background: none; border: none;
    color: var(--text-muted);
    font-size: 0.75rem; cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
  }
  .shop-tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
  }
  .shop-rotation-section {
    width: 100%; max-width: 400px;
    padding: 12px 14px 0;
  }
  .shop-rotation-header {
    display: flex; align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
  }
  .shop-rotation-title {
    font-size: 0.8rem; font-weight: bold;
    color: var(--coin-gold);
    letter-spacing: 0.5px;
  }
  .shop-rotation-timer {
    font-size: 0.7rem;
    color: var(--text-muted);
  }
  .shop-own-count {
    text-align: center;
    font-size: 0.7rem;
    color: var(--text-muted);
    padding: 8px 0 4px;
  }
  .shop-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    padding: 10px 14px 80px;
    width: 100%;
    max-width: 400px;
  }
  .shop-card {
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 14px;
    padding: 12px;
    text-align: center;
    position: relative;
    transition: transform 0.1s;
  }
  .shop-card:active { transform: scale(0.97); }
  .shop-card.equipped {
    border-color: var(--accent);
    box-shadow: 0 0 8px var(--accent-glow);
  }
  .shop-card-badge {
    position: absolute; top: 8px; left: 8px;
    background: #ff4757; color: #fff;
    font-size: 0.55rem; font-weight: bold;
    padding: 2px 6px; border-radius: 6px;
    letter-spacing: 0.5px;
  }
  .shop-card-badge.seasonal { background: #ff6b9d; }
  .shop-preview {
    display: flex; gap: 3px;
    justify-content: center; align-items: center;
    margin-bottom: 8px;
    min-height: 48px;
    flex-wrap: wrap;
  }
  .shop-preview-swatch {
    width: 20px; height: 20px;
    border-radius: 4px;
  }
  /* Block preview: mini tower */
  .shop-preview-tower {
    display: flex; flex-direction: column-reverse;
    align-items: center; gap: 1px;
  }
  .shop-preview-tower-block {
    border-radius: 3px; height: 8px;
  }
  /* Background preview: gradient rectangle */
  .shop-preview-bg {
    width: 56px; height: 44px;
    border-radius: 6px;
    border: 1px solid var(--card-border);
  }
  /* Effect preview: shape icons */
  .shop-preview-effects {
    display: flex; gap: 5px; justify-content: center; align-items: center;
  }
  .shop-preview-shape { width: 16px; height: 16px; }
  /* UI theme preview: mini UI mockup */
  .shop-preview-ui {
    width: 56px; height: 44px;
    border-radius: 6px; padding: 4px;
    border: 1px solid var(--card-border);
    display: flex; flex-direction: column;
    gap: 3px; align-items: center; justify-content: center;
    background: var(--bg-primary);
  }
  .shop-preview-ui-bar {
    width: 100%; height: 5px; border-radius: 2px;
  }
  .shop-preview-ui-btn {
    width: 60%; height: 8px; border-radius: 3px;
  }
  .shop-preview-ui-dot {
    width: 8px; height: 8px; border-radius: 50%;
  }
  .shop-card-name {
    font-size: 0.85rem; font-weight: bold;
    color: var(--text-primary);
    margin-bottom: 4px;
  }
  .shop-card-price {
    font-size: 0.8rem;
    color: var(--coin-gold);
    font-weight: bold;
    margin-bottom: 8px;
  }
  .shop-card-price.insufficient { color: #ff4757; }
  .shop-card-btn {
    width: 100%; padding: 7px 0;
    border-radius: 8px; border: none;
    font-size: 0.8rem; font-weight: bold;
    cursor: pointer; transition: all 0.2s;
  }
  .shop-card-btn.buy { background: var(--coin-gold); color: #1a1a2e; }
  .shop-card-btn.buy:disabled { background: var(--toggle-off); color: var(--text-muted); cursor: default; }
  .shop-card-btn.equip { background: var(--accent); color: #fff; }
  .shop-card-btn.equipped-btn {
    background: var(--card-bg); color: var(--accent);
    border: 1px solid var(--accent); cursor: default;
  }

  /* ===== Purchase Confirm Dialog ===== */
  #purchaseDialog {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.6);
    display: flex; align-items: center;
    justify-content: center;
    z-index: 25; padding: 2rem;
  }
  #purchaseDialog.hidden { display: none; }
  .purchase-box {
    background: var(--bg-primary);
    border: 1px solid var(--card-border);
    border-radius: 16px;
    padding: 24px; text-align: center;
    max-width: 280px; width: 100%;
  }
  .purchase-box h3 { font-size: 1.1rem; margin-bottom: 8px; }
  .purchase-preview {
    display: flex; gap: 3px;
    justify-content: center; align-items: center;
    margin-bottom: 12px;
    min-height: 48px;
  }
  .purchase-price {
    color: var(--coin-gold);
    font-size: 1.2rem; font-weight: bold;
    margin-bottom: 4px;
  }
  .purchase-balance {
    color: var(--text-muted);
    font-size: 0.8rem; margin-bottom: 16px;
  }
  .purchase-btns { display: flex; gap: 10px; }
  .purchase-btns button {
    flex: 1; padding: 10px; border-radius: 10px;
    border: none; font-size: 0.95rem;
    font-weight: bold; cursor: pointer;
  }
  .purchase-cancel-btn {
    background: var(--card-bg); color: var(--text-primary);
    border: 1px solid var(--card-border) !important;
  }
  .purchase-confirm-btn { background: var(--coin-gold); color: #1a1a2e; }

  /* ===== Leaderboard Screen ===== */
  #leaderboardScreen {
    position: fixed; inset: 0;
    background: var(--bg-overlay);
    backdrop-filter: blur(8px);
    display: flex; flex-direction: column;
    align-items: center;
    z-index: 20;
    padding: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  #leaderboardScreen.hidden { display: none; }
  .lb-header {
    position: sticky; top: 0;
    width: 100%;
    background: var(--bg-overlay);
    backdrop-filter: blur(12px);
    padding: 14px 18px;
    display: flex; align-items: center;
    justify-content: space-between;
    z-index: 2;
    border-bottom: 1px solid var(--card-border);
  }
  .lb-back-btn {
    background: none; border: none;
    color: var(--text-primary);
    font-size: 1.1rem; cursor: pointer;
    padding: 6px 12px;
  }
  .lb-title {
    font-size: 1.2rem; font-weight: bold;
    color: var(--text-primary);
  }
  .lb-my-rank {
    width: 100%; max-width: 400px;
    padding: 12px 18px;
    background: var(--card-bg);
    border-bottom: 1px solid var(--card-border);
    text-align: center;
  }
  .lb-my-rank-label {
    font-size: 0.7rem; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 1px;
    margin-bottom: 4px;
  }
  .lb-my-rank-score {
    font-size: 1.3rem; font-weight: bold;
    color: var(--accent);
    font-family: 'Courier New', monospace;
  }
  .lb-table {
    width: 100%; max-width: 400px;
    padding: 0 14px 80px;
  }
  .lb-row {
    display: flex; align-items: center;
    padding: 10px 8px;
    border-bottom: 1px solid var(--card-border);
    gap: 10px;
  }
  .lb-row.me {
    background: var(--card-bg);
    border-radius: 8px;
    border: 1px solid var(--accent);
  }
  .lb-rank {
    width: 32px; text-align: center;
    font-weight: bold; font-size: 0.9rem;
    color: var(--text-muted);
    flex-shrink: 0;
  }
  .lb-rank.gold { color: #ffd700; }
  .lb-rank.silver { color: #c0c0c0; }
  .lb-rank.bronze { color: #cd7f32; }
  .lb-name {
    flex: 1; font-size: 0.9rem;
    color: var(--text-primary);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .lb-score-col {
    text-align: right; font-weight: bold;
    font-size: 0.9rem; color: var(--accent);
    font-family: 'Courier New', monospace;
    flex-shrink: 0;
  }
  .lb-height-col {
    text-align: right; font-size: 0.75rem;
    color: var(--text-muted);
    width: 48px; flex-shrink: 0;
  }
  .lb-loading, .lb-error, .lb-empty {
    text-align: center; padding: 40px 20px;
    color: var(--text-muted); font-size: 0.9rem;
  }
  .lb-error { color: #ff4757; }

  /* ===== FOMO / Start Screen Extras ===== */
  .start-skins-info {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
  }
  .start-fomo-text {
    font-size: 0.75rem;
    color: var(--coin-gold);
    margin-bottom: 0.8rem;
    opacity: 0.8;
  }
  .start-equipped-row {
    display: flex; gap: 4px;
    justify-content: center;
    margin-bottom: 0.5rem;
  }
  .start-equipped-swatch {
    width: 14px; height: 14px;
    border-radius: 3px;
  }
  /* Game over ranking btn */
  .btn-ranking {
    background: transparent;
    border: 1px solid var(--card-border);
    color: var(--text-muted);
    padding: 10px 30px; border-radius: 12px;
    font-size: 0.9rem; cursor: pointer;
    margin-bottom: 8px;
    transition: transform 0.1s;
  }
  .btn-ranking:active { transform: scale(0.95); }
  .btn-home {
    background: transparent;
    border: 1px solid var(--card-border);
    color: var(--text-muted);
    padding: 10px 30px; border-radius: 12px;
    font-size: 0.9rem; cursor: pointer;
    margin-top: 4px;
    transition: transform 0.1s;
  }
  .btn-home:active { transform: scale(0.95); }
  #rankingSubmitSection .ranking-retry-btn {
    background: var(--accent); color: #fff;
    border: none; padding: 4px 14px; border-radius: 8px;
    font-size: 0.8rem; cursor: pointer; margin-left: 6px;
  }
  #rankingSubmitSection .ranking-retry-btn:active { transform: scale(0.95); }
  #rankingSubmitSection .ranking-name-link {
    color: var(--accent); text-decoration: underline;
    cursor: pointer;
  }
</style>
</head>
<body>

<!-- Name Prompt -->
<div id="namePrompt" class="hidden">
  <div class="np-title">Welcome!</div>
  <p>ÂêçÂâç„ÇíÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ</p>
  <input type="text" id="nameInput" placeholder="ÂêçÂâç" maxlength="20">
  <button class="btn" id="nameOkBtn">OK</button>
</div>

<!-- Settings Screen -->
<div id="settingsScreen" class="hidden">
  <h2>Settings</h2>
  <div class="setting-card">
    <div class="s-label">ÂêçÂâç</div>
    <input type="text" id="settingsName" maxlength="20">
  </div>
  <div class="setting-card">
    <div class="s-label">„ÉÜ„Éº„Éû</div>
    <div class="theme-selector">
      <button class="theme-opt" data-theme="auto">Ëá™Âãï</button>
      <button class="theme-opt" data-theme="dark">„ÉÄ„Éº„ÇØ</button>
      <button class="theme-opt" data-theme="light">„É©„Ç§„Éà</button>
    </div>
  </div>
  <div class="setting-card">
    <div class="s-label">ÂÇæ„ÅçÊÑüÂ∫¶</div>
    <input type="range" id="sensitivitySlider" min="0.5" max="6.0" step="0.1" value="3.0">
    <div class="range-display" id="sensitivityVal">3.0</div>
  </div>
  <div class="setting-card" id="soundGroup">
    <div class="s-toggle-row">
      <span class="s-toggle-label">ÂäπÊûúÈü≥</span>
      <div class="toggle" id="soundToggle"></div>
    </div>
  </div>
  <div class="setting-card" id="vibrationGroup" style="display:none;">
    <div class="s-toggle-row">
      <span class="s-toggle-label">„Éê„Ç§„Éñ„É¨„Éº„Ç∑„Éß„É≥</span>
      <div class="toggle" id="vibrationToggle"></div>
    </div>
  </div>
  <button class="btn" id="settingsCloseBtn" style="margin-top:12px;">Èñâ„Åò„Çã</button>
</div>

<!-- Shop Screen -->
<div id="shopScreen" class="hidden">
  <div class="shop-header">
    <button class="shop-back-btn" id="shopBackBtn">‚Üê Êàª„Çã</button>
    <span class="shop-title">„Ç∑„Éß„ÉÉ„Éó</span>
    <span class="shop-coins">ü™ô <span id="shopCoins">0</span></span>
  </div>
  <div class="shop-tabs">
    <button class="shop-tab active" data-tab="blocks">„Éñ„É≠„ÉÉ„ÇØ</button>
    <button class="shop-tab" data-tab="backgrounds">ËÉåÊôØ</button>
    <button class="shop-tab" data-tab="effects">„Ç®„Éï„Çß„ÇØ„Éà</button>
    <button class="shop-tab" data-tab="uiThemes">UI</button>
  </div>
  <div id="shopRotationSection" class="shop-rotation-section" style="display:none;">
    <div class="shop-rotation-header">
      <span class="shop-rotation-title">‚òÖ ‰ªäÈÄ±„ÅÆ„Åä„Åô„Åô„ÇÅ</span>
      <span class="shop-rotation-timer" id="rotationTimer"></span>
    </div>
    <div class="shop-grid" id="shopRotationGrid"></div>
  </div>
  <div class="shop-own-count" id="shopOwnCount"></div>
  <div class="shop-grid" id="shopGrid"></div>
</div>

<!-- Purchase Dialog -->
<div id="purchaseDialog" class="hidden">
  <div class="purchase-box">
    <h3 id="purchaseItemName"></h3>
    <div class="purchase-preview" id="purchasePreview"></div>
    <div class="purchase-price" id="purchasePrice"></div>
    <div class="purchase-balance" id="purchaseBalance"></div>
    <div class="purchase-btns">
      <button class="purchase-cancel-btn" id="purchaseCancelBtn">„ÇÑ„ÇÅ„Çã</button>
      <button class="purchase-confirm-btn" id="purchaseConfirmBtn">Ë≥ºÂÖ•„Åô„Çã</button>
    </div>
  </div>
</div>

<!-- Leaderboard Screen -->
<div id="leaderboardScreen" class="hidden">
  <div class="lb-header">
    <button class="lb-back-btn" id="lbBackBtn">‚Üê Êàª„Çã</button>
    <span class="lb-title">„É©„É≥„Ç≠„É≥„Ç∞</span>
    <span style="width:48px;"></span>
  </div>
  <div class="lb-my-rank" id="lbMyRank">
    <div class="lb-my-rank-label">„ÅÇ„Å™„Åü</div>
    <div class="lb-my-rank-score" id="lbMyScore">---</div>
  </div>
  <div class="lb-table" id="lbTable">
    <div class="lb-loading" id="lbLoading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
  </div>
</div>

<!-- Share Toast -->
<div id="shareToast">Copied!</div>

<!-- Permission Prompt -->
<div id="permissionPrompt" class="hidden">
  <div class="perm-title">ÂÇæ„Åç„Çª„É≥„Çµ„Éº„ÅÆË®±ÂèØ</div>
  <p>„Åì„ÅÆ„Ç≤„Éº„É†„ÅØ„Çπ„Éû„Éõ„ÅÆÂÇæ„Åç„ÅßÊìç‰Ωú„Åó„Åæ„Åô„ÄÇ<br>Ë®±ÂèØ„Çí„Çø„ÉÉ„Éó„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
  <button class="btn" id="permissionBtn">Ë®±ÂèØ„Åô„Çã</button>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen">
  <button id="shopBtn">
    üõí
    <span class="shop-notify-dot" id="shopNotifyDot"></span>
  </button>
  <button id="settingsBtn">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="3"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
  </button>
  <button id="rankingBtn">üèÜ</button>
  <h1>Tilt Tower</h1>
  <p class="subtitle">„Å©„Åì„Åæ„ÅßÁ©ç„ÇÅ„ÇãÔºü</p>
  <p class="start-best" id="startBest"></p>
  <p class="start-greeting" id="startGreeting"></p>
  <div class="start-equipped-row" id="startEquippedRow"></div>
  <div id="startCoins" class="start-coins">ü™ô <span id="coinBalance">0</span></div>
  <div id="startFomo" class="start-fomo-text" style="display:none;"></div>
  <div id="dailyBonusCard" class="hidden">
    <div class="daily-title">„Éá„Ç§„É™„Éº„Éú„Éº„Éä„Çπ</div>
    <div class="daily-dots" id="dailyDots"></div>
    <div class="daily-reward" id="dailyRewardText"></div>
    <div class="daily-multiplier" id="dailyMultText"></div>
    <div id="dailyActionArea"></div>
  </div>
  <button class="btn" id="startBtn">START</button>
</div>

<!-- Game Over Screen -->
<div id="gameOverScreen" class="screen hidden">
  <div id="newBestBadge">NEW BEST!</div>
  <h2 id="gameOverTitle">NICE TOWER!</h2>
  <div class="height-display" id="heightDisplay"></div>
  <div class="score-display" id="finalScore"></div>
  <div id="peakMoment"></div>
  <div id="nearBest" style="color:var(--accent);font-size:0.9rem;font-weight:bold;margin-bottom:0.8rem;min-height:1.2em;"></div>
  <div id="coinReward">ü™ô +<span id="coinEarnedVal">0</span></div>
  <div id="streakMultiplier"></div>
  <div class="best-score" id="bestScore"></div>
  <button class="btn-share" id="shareBtn">Share</button>
  <div id="rankingSubmitSection" style="font-size:0.85rem;margin-bottom:8px;min-height:1.4em;color:var(--text-muted);"></div>
  <button class="btn-ranking" id="goRankingBtn">üèÜ „É©„É≥„Ç≠„É≥„Ç∞</button>
  <button class="btn" id="retryBtn">RETRY</button>
  <button class="btn-home" id="goHomeBtn">üè† „Éõ„Éº„É†</button>
</div>

<!-- HUD -->
<div id="hud" style="display:none;">
  <div><div class="label">SCORE</div><div class="value" id="scoreVal">0</div></div>
  <div style="text-align:center;"><div class="label">HEIGHT</div><div class="value" id="heightVal">0m</div></div>
  <div style="text-align:right;"><div class="label">BLOCKS</div><div class="value" id="blockCount">0</div></div>
</div>
<div id="hudCoins" style="display:none;">ü™ô <span id="hudCoinVal">0</span></div>

<!-- Combo Gauge -->
<div id="comboGauge">
  <div id="comboTrack"><div id="comboFill"></div></div>
  <div id="comboLabel"></div>
</div>

<!-- Tilt Indicator -->
<div id="tiltIndicator" style="display:none;">
  <span>L</span>
  <div id="tiltBar"><div id="tiltDot"></div></div>
  <span>R</span>
</div>

<canvas id="gameCanvas"></canvas>

<script>
// ===== Theme =====
const themePref = localStorage.getItem('tiltTowerTheme') || 'auto';
function applyTheme(mode) {
  let dark = true;
  if (mode === 'light') dark = false;
  else if (mode === 'auto') dark = window.matchMedia('(prefers-color-scheme: dark)').matches || !window.matchMedia('(prefers-color-scheme: light)').matches;
  document.documentElement.classList.toggle('light', !dark);
  document.getElementById('metaThemeColor').content = dark ? '#0a0a2e' : '#f0f4f8';
}
applyTheme(themePref);
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
  if ((localStorage.getItem('tiltTowerTheme') || 'auto') === 'auto') applyTheme('auto');
});

// Theme colors for canvas (read from resolved CSS)
function getCanvasThemeColors() {
  const isDark = !document.documentElement.classList.contains('light');
  return isDark ? {
    bgTop: '#0a0a2e', bgBot: '#1a1a4e',
    grid: 'rgba(255,255,255,0.03)',
    marker: 'rgba(255,255,255,0.1)',
    text: '#fff', muted: 'rgba(255,255,255,0.5)',
    guide: 'rgba(255,255,255,0.15)',
  } : {
    bgTop: '#f0f4f8', bgBot: '#dce3ed',
    grid: 'rgba(0,0,0,0.04)',
    marker: 'rgba(0,0,0,0.08)',
    text: '#1a1a2e', muted: 'rgba(26,26,46,0.5)',
    guide: 'rgba(0,0,0,0.1)',
  };
}

// ===== Sound Engine (Web Audio API) =====
let audioCtx = null;
let soundEnabled = localStorage.getItem('tiltTowerSound') !== 'off';

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function resumeAudio() {
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(type, freq, dur, vol, freqEnd) {
  if (!audioCtx || !soundEnabled) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t);
  if (freqEnd) osc.frequency.linearRampToValueAtTime(freqEnd, t + dur / 1000);
  gain.gain.setValueAtTime(vol, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + dur / 1000);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(t);
  osc.stop(t + dur / 1000 + 0.05);
}

function sfxPlace() {
  // "ton" ‚Äî triangle 220Hz with slight random variation
  const pitch = 220 * (0.95 + Math.random() * 0.1);
  playTone('triangle', pitch, 100, 0.25, pitch * 0.82);
}

function sfxPerfect(combo) {
  // Pentatonic escalation: C5, D5, E5, G5, A5, C6
  const notes = [523, 587, 659, 784, 880, 1047];
  const note = notes[Math.min(combo - 1, notes.length - 1)];
  playTone('sine', note, 180, 0.22);
  // Add harmony for combo 3+
  if (combo >= 3) {
    setTimeout(() => playTone('sine', note * 1.25, 150, 0.12), 60);
  }
}

function sfxGameOver() {
  // Descending: E4 -> C4 -> A3
  playTone('sawtooth', 330, 200, 0.15, 310);
  setTimeout(() => playTone('sawtooth', 262, 200, 0.15, 245), 150);
  setTimeout(() => playTone('sawtooth', 220, 400, 0.15, 180), 320);
}

function sfxNewBest() {
  // Fanfare: C5 -> E5 -> G5 -> C6
  playTone('sine', 523, 150, 0.2);
  setTimeout(() => playTone('sine', 659, 150, 0.2), 120);
  setTimeout(() => playTone('sine', 784, 150, 0.2), 240);
  setTimeout(() => playTone('sine', 1047, 300, 0.25), 380);
}

function sfxButton() {
  playTone('sine', 800, 40, 0.1);
}

function sfxMilestone() {
  playTone('sine', 660, 120, 0.18);
  setTimeout(() => playTone('sine', 880, 200, 0.2), 100);
}

function sfxBonus() {
  playTone('triangle', 880, 100, 0.18);
  setTimeout(() => playTone('sine', 1047, 150, 0.2), 80);
  setTimeout(() => playTone('sine', 1319, 200, 0.15), 180);
}

function sfxCoinEarn() {
  // Rising arpeggio: coin collect feel
  playTone('sine', 987, 60, 0.15);
  setTimeout(() => playTone('sine', 1175, 60, 0.15), 50);
  setTimeout(() => playTone('sine', 1480, 100, 0.18), 100);
}

function sfxDailyBonus() {
  // C6 ‚Üí E6 ‚Üí G6 celebration
  playTone('sine', 1047, 120, 0.18);
  setTimeout(() => playTone('sine', 1319, 120, 0.18), 100);
  setTimeout(() => playTone('sine', 1568, 200, 0.22), 200);
}

// ===== Performance =====
const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const MAX_PARTICLES = isMobile ? 50 : 100;
const MAX_TEXT_PARTICLES = isMobile ? 6 : 12;
const PARTICLE_MULT = isMobile ? 0.4 : 1.0; // spawn count multiplier

// ===== Config =====
const GRAVITY = 0.06;
const DROP_SPEED_INIT = 1.5;
const DROP_SPEED_INCREMENT = 0.05;
let TILT_SENSITIVITY = parseFloat(localStorage.getItem('tiltTowerSensitivity') || '3.0');
const BLOCK_HEIGHT = 40;
const INITIAL_BLOCK_WIDTH = 160;
const MIN_BLOCK_WIDTH = 20;
const PERFECT_THRESHOLD = 5;
const CAMERA_LERP = 0.05;

// ===== State =====
let canvas, ctx;
let W, H;
let gameState = 'start';
let tiltX = 0;
let score = 0;
let bestScoreVal = parseInt(localStorage.getItem('tiltTowerBest') || '0');
let cameraY = 0;
let targetCameraY = 0;
let blocks = [];
let currentBlock = null;
let dropSpeed = DROP_SPEED_INIT;
let particles = [];
let textParticles = []; // floating score text
let shakeAmount = 0;
let comboCount = 0;
let peakCombo = 0;
let hasMotionPermission = false;
let usingMouse = false;
let playerName = localStorage.getItem('tiltTowerName') || '';
let vibrationSupported = typeof navigator.vibrate === 'function';
let vibrationEnabled = vibrationSupported && localStorage.getItem('tiltTowerVibration') !== 'off';
let freezeFrames = 0; // hitstop counter
let milestoneText = '';
let milestoneTimer = 0;
let consecutiveMisses = 0; // for adaptive difficulty

// ===== Coin Economy =====
let coinBalance = parseInt(localStorage.getItem('tiltTower_coins') || '0');
let totalCoinsEarned = parseInt(localStorage.getItem('tiltTower_totalCoinsEarned') || '0');

// Daily Bonus / Streak
const DAILY_REWARDS = [5, 8, 12, 18, 25, 35, 50];
const STREAK_MULTIPLIERS = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6];
let dailyStreak = parseInt(localStorage.getItem('tiltTower_dailyStreak') || '0');
let lastDailyClaimDate = localStorage.getItem('tiltTower_lastDailyClaimDate') || '';
let longestStreak = parseInt(localStorage.getItem('tiltTower_longestStreak') || '0');

function saveCoins() {
  localStorage.setItem('tiltTower_coins', coinBalance.toString());
  localStorage.setItem('tiltTower_totalCoinsEarned', totalCoinsEarned.toString());
}

function addCoins(amount) {
  coinBalance += amount;
  totalCoinsEarned += amount;
  saveCoins();
}

function getStreakMultiplier() {
  const idx = Math.min(Math.max(dailyStreak, 0), STREAK_MULTIPLIERS.length - 1);
  return STREAK_MULTIPLIERS[idx];
}

function calculateCoinsEarned(finalScore, peak) {
  let raw = Math.floor(finalScore / 200);
  if (peak >= 3) raw += peak * 2;
  return Math.max(1, raw);
}

function getTodayDateStr() {
  const d = new Date();
  return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
}

function daysBetween(dateStr1, dateStr2) {
  if (!dateStr1 || !dateStr2) return Infinity;
  const d1 = new Date(dateStr1 + 'T00:00:00');
  const d2 = new Date(dateStr2 + 'T00:00:00');
  return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
}

function checkDailyStreakStatus() {
  const today = getTodayDateStr();
  if (!lastDailyClaimDate) return; // first time, nothing to check
  const gap = daysBetween(lastDailyClaimDate, today);
  if (gap > 1) {
    // Missed days: 2-step penalty instead of full reset
    const penalty = Math.min(dailyStreak, 2);
    dailyStreak = Math.max(0, dailyStreak - penalty);
    localStorage.setItem('tiltTower_dailyStreak', dailyStreak.toString());
  }
}

function isDailyBonusAvailable() {
  return lastDailyClaimDate !== getTodayDateStr();
}

function claimDailyBonus() {
  const rewardIdx = dailyStreak % DAILY_REWARDS.length;
  const reward = DAILY_REWARDS[rewardIdx];
  addCoins(reward);
  dailyStreak++;
  if (dailyStreak > longestStreak) {
    longestStreak = dailyStreak;
    localStorage.setItem('tiltTower_longestStreak', longestStreak.toString());
  }
  // Reset after Day 7
  if (dailyStreak >= DAILY_REWARDS.length) {
    dailyStreak = 0;
  }
  lastDailyClaimDate = getTodayDateStr();
  localStorage.setItem('tiltTower_dailyStreak', dailyStreak.toString());
  localStorage.setItem('tiltTower_lastDailyClaimDate', lastDailyClaimDate);
  sfxDailyBonus();
  vibrate([20, 30, 20, 30, 60]);
  updateDailyBonusCard();
  updateCoinDisplay();
}

function updateCoinDisplay() {
  document.getElementById('coinBalance').textContent = coinBalance;
  document.getElementById('hudCoinVal').textContent = coinBalance;
}

function updateDailyBonusCard() {
  const card = document.getElementById('dailyBonusCard');
  const dotsEl = document.getElementById('dailyDots');
  const rewardText = document.getElementById('dailyRewardText');
  const multText = document.getElementById('dailyMultText');
  const actionArea = document.getElementById('dailyActionArea');

  card.classList.remove('hidden');

  // Build 7-day dots
  const currentDay = dailyStreak % DAILY_REWARDS.length;
  let dotsHTML = '';
  for (let i = 0; i < DAILY_REWARDS.length; i++) {
    let cls = 'daily-dot';
    if (isDailyBonusAvailable()) {
      // Haven't claimed today
      if (i < currentDay) cls += ' claimed';
      else if (i === currentDay) cls += ' current';
    } else {
      // Already claimed today: streak was already incremented (and possibly reset)
      // Figure out which day was just claimed
      const claimedUpTo = dailyStreak > 0 ? dailyStreak - 1 : DAILY_REWARDS.length - 1;
      if (i <= claimedUpTo) cls += ' claimed';
    }
    dotsHTML += `<div class="${cls}">${i + 1}</div>`;
  }
  dotsEl.innerHTML = dotsHTML;

  if (isDailyBonusAvailable()) {
    const reward = DAILY_REWARDS[currentDay];
    rewardText.textContent = `ü™ô +${reward}`;
    const mult = STREAK_MULTIPLIERS[Math.min(currentDay, STREAK_MULTIPLIERS.length - 1)];
    multText.textContent = mult > 1.0 ? `„Ç≤„Éº„É†Â†±ÈÖ¨ x${mult.toFixed(1)} „Éú„Éº„Éä„Çπ‰∏≠` : '';
    actionArea.innerHTML = `<button class="daily-claim-btn" id="dailyClaimBtn">Âèó„ÅëÂèñ„Çã</button>`;
    document.getElementById('dailyClaimBtn').addEventListener('click', () => {
      initAudio();
      resumeAudio();
      claimDailyBonus();
    });
  } else {
    rewardText.textContent = '';
    const mult = getStreakMultiplier();
    multText.textContent = mult > 1.0 ? `„Ç≤„Éº„É†Â†±ÈÖ¨ x${mult.toFixed(1)} „Éú„Éº„Éä„Çπ‰∏≠` : '';
    const dayLabel = dailyStreak > 0 ? dailyStreak : (lastDailyClaimDate === getTodayDateStr() ? DAILY_REWARDS.length : 0);
    actionArea.innerHTML = `<div class="daily-claimed-text">ÂèóÂèñÊ∏à„Åø ‚úì Day ${dayLabel}/${DAILY_REWARDS.length}</div>`;
  }
}

// ===== Block Colors =====
const BLOCK_COLORS = [
  ['#4facfe', '#00b4d8'],
  ['#a78bfa', '#e879f9'],
  ['#f472b6', '#fb7185'],
  ['#4facfe', '#34d399'],
  ['#fb923c', '#fbbf24'],
  ['#6ee7b7', '#a7f3d0'],
  ['#a3e635', '#4ade80'],
  ['#fcd34d', '#fdba74'],
];

// ===== Skin Data =====
const BLOCK_SKINS = {
  default: { id:'default', name:'„Éá„Éï„Ç©„É´„Éà', price:0, colors:[['#4facfe','#00b4d8'],['#a78bfa','#e879f9'],['#f472b6','#fb7185'],['#4facfe','#34d399'],['#fb923c','#fbbf24'],['#6ee7b7','#a7f3d0'],['#a3e635','#4ade80'],['#fcd34d','#fdba74']] },
  neon: { id:'neon', name:'„Éç„Ç™„É≥', price:300, colors:[['#ff00ff','#ff44cc'],['#00ff88','#44ffaa'],['#00ccff','#44ddff'],['#ffff00','#ffcc00'],['#ff4444','#ff6666'],['#ff8800','#ffaa44'],['#aa00ff','#cc44ff'],['#00ffff','#44ffff']] },
  pastel: { id:'pastel', name:'„Éë„Çπ„ÉÜ„É´', price:200, colors:[['#ffc8dd','#ffafcc'],['#bde0fe','#a2d2ff'],['#cdb4db','#e2c2f0'],['#a8dadc','#b5e2e0'],['#ffd6a5','#ffcb8e'],['#caffbf','#b8f0a8'],['#fdffb6','#faf0a0'],['#ffc6ff','#f0b0f0']] },
  metallic: { id:'metallic', name:'„É°„Çø„É™„ÉÉ„ÇØ', price:500, colors:[['#c0c0c0','#a8a8a8'],['#ffd700','#daa520'],['#cd7f32','#b87333'],['#b0c4de','#8fafc8'],['#e5e4e2','#c0c0c0'],['#d4af37','#c5a028'],['#8c7853','#7a6845'],['#aaa9ad','#9898a0']] },
  ocean: { id:'ocean', name:'„Ç™„Éº„Ç∑„É£„É≥', price:350, colors:[['#006994','#014f73'],['#00a6fb','#0085d0'],['#00d4aa','#00b89c'],['#48cae4','#3ab8d2'],['#0077b6','#005f92'],['#90e0ef','#70c8dd'],['#023e8a','#012d6b'],['#caf0f8','#a8d8e8']] },
  sakura: { id:'sakura', name:'Ê°ú', price:400, seasonal:{month:4}, colors:[['#ffb7c5','#ff9eb5'],['#ffc0cb','#ffaabb'],['#fff0f5','#ffe0eb'],['#ff69b4','#ff5aa0'],['#ffb6c1','#ffa0b0'],['#ffd1dc','#ffbfcc'],['#ff85a2','#ff7092'],['#ffe4e1','#ffd0cc']] },
  cyber: { id:'cyber', name:'„Çµ„Ç§„Éê„Éº', price:600, colors:[['#0ff','#0cc'],['#f0f','#c0c'],['#0f0','#0c0'],['#ff0','#cc0'],['#f00','#c00'],['#00f','#00c'],['#f80','#c60'],['#80f','#60c']] },
  galaxy: { id:'galaxy', name:'ÈäÄÊ≤≥', price:800, rotation:true, colors:[['#4b0082','#380060'],['#8a2be2','#7020c0'],['#9370db','#7b60c8'],['#483d8b','#362c70'],['#6a5acd','#5848b0'],['#7b68ee','#6858d8'],['#e6e6fa','#d4d4f0'],['#dda0dd','#cc90cc']] },
};

const BG_THEMES = {
  default: { id:'default', name:'„Éá„Éï„Ç©„É´„Éà', price:0,
    darkStages:[{t:'#0a0a2e',b:'#1a1a4e'},{t:'#1a0a3e',b:'#3a1a4e'},{t:'#2a1040',b:'#6b2040'},{t:'#050510',b:'#0a0a2e'}],
    lightStages:[{t:'#f0f4f8',b:'#dce3ed'},{t:'#e8ecf4',b:'#d0d8e8'},{t:'#e4ddf0',b:'#cfc4e6'},{t:'#f0e0d8',b:'#e8d0c0'}],
    overlay:null, previewColors:['#0a0a2e','#1a1a4e','#3a1a4e','#6b2040'] },
  ocean: { id:'ocean', name:'Ê∑±Êµ∑', price:400,
    darkStages:[{t:'#001220',b:'#002040'},{t:'#001830',b:'#003060'},{t:'#002040',b:'#004080'},{t:'#000810',b:'#001830'}],
    lightStages:[{t:'#e0f0ff',b:'#c0e0f8'},{t:'#d0e8ff',b:'#b0d8f0'},{t:'#c0e0ff',b:'#a0d0e8'},{t:'#e8f4ff',b:'#d0e8f8'}],
    overlay:'bubbles', previewColors:['#001220','#002040','#003060','#004080'] },
  sakuraBg: { id:'sakuraBg', name:'Ê°ú‰∏¶Êú®', price:450, seasonal:{month:4},
    darkStages:[{t:'#1a0a1e',b:'#2a1028'},{t:'#2a1028',b:'#3a1838'},{t:'#3a1838',b:'#4a2048'},{t:'#0a0510',b:'#1a0a1e'}],
    lightStages:[{t:'#fff0f5',b:'#ffe4ed'},{t:'#ffe8f0',b:'#ffd8e5'},{t:'#ffdce5',b:'#ffccdd'},{t:'#fff4f8',b:'#ffe8f0'}],
    overlay:'petals', previewColors:['#fff0f5','#ffc0cb','#ff69b4','#ffb7c5'] },
  cyberpunk: { id:'cyberpunk', name:'„Çµ„Ç§„Éê„Éº„Éë„É≥„ÇØ', price:500,
    darkStages:[{t:'#0a0014',b:'#14002a'},{t:'#14002a',b:'#1e0040'},{t:'#1e0040',b:'#280060'},{t:'#050010',b:'#0a0014'}],
    lightStages:[{t:'#f0e4ff',b:'#e0d0ff'},{t:'#e8d8ff',b:'#d8c4ff'},{t:'#e0ccff',b:'#d0b8ff'},{t:'#f4ecff',b:'#e8dcff'}],
    overlay:'scanlines', previewColors:['#0a0014','#14002a','#1e0040','#f0f'] },
  sunset: { id:'sunset', name:'„Çµ„É≥„Çª„ÉÉ„Éà', price:450, rotation:true,
    darkStages:[{t:'#1a0a00',b:'#2a1500'},{t:'#2a1500',b:'#4a2000'},{t:'#4a2000',b:'#6b3000'},{t:'#0a0500',b:'#1a0a00'}],
    lightStages:[{t:'#fff8f0',b:'#ffe8d0'},{t:'#fff0e0',b:'#ffe0c0'},{t:'#ffe8d0',b:'#ffd8b0'},{t:'#fffaf4',b:'#fff0e4'}],
    overlay:null, previewColors:['#ff8c00','#ff6347','#ff4500','#ffd700'] },
  snow: { id:'snow', name:'Èõ™', price:400, seasonal:{month:12},
    darkStages:[{t:'#0a1020',b:'#142040'},{t:'#142040',b:'#1e3060'},{t:'#1e3060',b:'#284080'},{t:'#050810',b:'#0a1020'}],
    lightStages:[{t:'#f0f4ff',b:'#e0e8f8'},{t:'#e8f0ff',b:'#d8e4f0'},{t:'#e0ecff',b:'#d0e0e8'},{t:'#f4f8ff',b:'#e8f0f8'}],
    overlay:'snowfall', previewColors:['#e0ecff','#c0d8f0','#a0c4e0','#fff'] },
};

const EFFECT_SKINS = {
  default: { id:'default', name:'„Éá„Éï„Ç©„É´„Éà', price:0, shape:'circle',
    colors:['#ffe066','#ff6b6b','#4facfe','#34d399','#e879f9'], previewColors:['#ffe066','#ff6b6b','#4facfe','#34d399'] },
  fire: { id:'fire', name:'ÁÇé', price:350, shape:'circle',
    colors:['#ff4500','#ff6600','#ff8800','#ffaa00','#ffcc00'], previewColors:['#ff4500','#ff6600','#ff8800','#ffcc00'] },
  starEffect: { id:'starEffect', name:'Êòü', price:400, shape:'star',
    colors:['#ffd700','#fff8dc','#ffe4b5','#ffdab9','#fff'], previewColors:['#ffd700','#fff8dc','#ffe4b5','#fff'] },
  flowers: { id:'flowers', name:'Ëä±„Å≥„Çâ', price:400, seasonal:{month:4}, shape:'petal',
    colors:['#ffb7c5','#ffc0cb','#ff69b4','#ff85a2','#fff0f5'], previewColors:['#ffb7c5','#ffc0cb','#ff69b4','#fff0f5'] },
  snowflakes: { id:'snowflakes', name:'Èõ™', price:400, seasonal:{month:12}, shape:'snowflake',
    colors:['#e0f0ff','#c0e0ff','#a0d0ff','#ffffff','#d0e8ff'], previewColors:['#e0f0ff','#c0e0ff','#fff','#d0e8ff'] },
  pixel: { id:'pixel', name:'„Éî„ÇØ„Çª„É´', price:500, rotation:true, shape:'square',
    colors:['#00ff00','#ff00ff','#00ffff','#ffff00','#ff0000'], previewColors:['#00ff00','#ff00ff','#00ffff','#ffff00'] },
};

const UI_THEMES = {
  default: { id:'default', name:'„Éá„Éï„Ç©„É´„Éà', price:0, vars:{}, previewColors:['#4facfe','#ffe066','#fff'] },
  retro: { id:'retro', name:'„É¨„Éà„É≠', price:300,
    vars:{'--accent':'#e74c3c','--accent-glow':'rgba(231,76,60,0.4)','--coin-gold':'#f39c12','--coin-glow':'rgba(243,156,18,0.4)'},
    previewColors:['#e74c3c','#f39c12','#2ecc71'] },
  minimal: { id:'minimal', name:'„Éü„Éã„Éû„É´', price:250,
    vars:{'--accent':'#888','--accent-glow':'rgba(136,136,136,0.3)','--coin-gold':'#aaa','--coin-glow':'rgba(170,170,170,0.3)'},
    previewColors:['#888','#aaa','#ccc'] },
  neonGlow: { id:'neonGlow', name:'„Éç„Ç™„É≥„Ç∞„É≠„Éº', price:500, rotation:true,
    vars:{'--accent':'#f0f','--accent-glow':'rgba(255,0,255,0.5)','--coin-gold':'#0ff','--coin-glow':'rgba(0,255,255,0.4)'},
    previewColors:['#f0f','#0ff','#0f0'] },
  matcha: { id:'matcha', name:'ÊäπËå∂', price:350,
    vars:{'--accent':'#8bc34a','--accent-glow':'rgba(139,195,74,0.4)','--coin-gold':'#cddc39','--coin-glow':'rgba(205,220,57,0.4)'},
    previewColors:['#8bc34a','#cddc39','#4caf50'] },
};

// ===== Inventory =====
let ownedSkins = { blocks:['default'], backgrounds:['default'], effects:['default'], uiThemes:['default'] };
let equippedSkins = { blocks:'default', backgrounds:'default', effects:'default', uiThemes:'default' };

function loadInventory() {
  try { const o = JSON.parse(localStorage.getItem('tiltTower_ownedSkins')); if (o) ownedSkins = o; } catch(e) {}
  try { const e = JSON.parse(localStorage.getItem('tiltTower_equippedSkins')); if (e) equippedSkins = e; } catch(e) {}
  // Ensure defaults
  ['blocks','backgrounds','effects','uiThemes'].forEach(cat => {
    if (!ownedSkins[cat]) ownedSkins[cat] = ['default'];
    if (!ownedSkins[cat].includes('default')) ownedSkins[cat].unshift('default');
    if (!equippedSkins[cat]) equippedSkins[cat] = 'default';
  });
}

function saveInventory() {
  localStorage.setItem('tiltTower_ownedSkins', JSON.stringify(ownedSkins));
  localStorage.setItem('tiltTower_equippedSkins', JSON.stringify(equippedSkins));
}

loadInventory();

// ===== Rotation & Seasonal =====
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function getISOWeek(d) {
  const date = new Date(d.getTime());
  date.setHours(0,0,0,0);
  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
  const week1 = new Date(date.getFullYear(), 0, 4);
  return 1 + Math.round(((date - week1) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
}

function getWeeklyRotation(date) {
  const d = date || new Date();
  const seed = d.getFullYear() * 100 + getISOWeek(d);
  const rng = mulberry32(seed);
  // Collect all rotation items across categories
  const rotationItems = [];
  const addItems = (catalog) => {
    for (const [id, item] of Object.entries(catalog)) {
      if (item.rotation) rotationItems.push(id);
    }
  };
  addItems(BLOCK_SKINS); addItems(BG_THEMES); addItems(EFFECT_SKINS); addItems(UI_THEMES);
  // Shuffle and pick 2-3
  for (let i = rotationItems.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [rotationItems[i], rotationItems[j]] = [rotationItems[j], rotationItems[i]];
  }
  return rotationItems.slice(0, Math.min(3, rotationItems.length));
}

function getNextMondayMs() {
  const now = new Date();
  const day = now.getDay();
  const daysUntilMonday = day === 0 ? 1 : (8 - day);
  const next = new Date(now);
  next.setDate(now.getDate() + daysUntilMonday);
  next.setHours(0, 0, 0, 0);
  return next.getTime() - now.getTime();
}

function formatCountdown(ms) {
  const hours = Math.floor(ms / 3600000);
  const days = Math.floor(hours / 24);
  const h = hours % 24;
  if (days > 0) return `ÊÆã„Çä${days}Êó•${h}ÊôÇÈñì`;
  return `ÊÆã„Çä${h}ÊôÇÈñì`;
}

function isSeasonalAvailable(item) {
  if (!item.seasonal) return true;
  return (new Date().getMonth() + 1) === item.seasonal.month;
}

// ===== Shop Logic =====
let currentShopTab = 'blocks';
let pendingPurchase = null;

function getCatalogForTab(tab) {
  if (tab === 'blocks') return BLOCK_SKINS;
  if (tab === 'backgrounds') return BG_THEMES;
  if (tab === 'effects') return EFFECT_SKINS;
  if (tab === 'uiThemes') return UI_THEMES;
  return BLOCK_SKINS;
}

function generatePreview(item, category) {
  if (category === 'blocks' && item.colors) {
    // Mini tower: 4 stacked blocks
    const samples = item.colors.slice(0, 4);
    const widths = [36, 32, 28, 24];
    const blocks = samples.map((c, i) => {
      const c0 = Array.isArray(c) ? c[0] : c;
      const c1 = Array.isArray(c) ? c[1] : c;
      return `<div class="shop-preview-tower-block" style="width:${widths[i]}px;background:linear-gradient(135deg,${c0},${c1})"></div>`;
    }).join('');
    return `<div class="shop-preview-tower">${blocks}</div>`;
  }
  if (category === 'backgrounds' && item.previewColors) {
    const cols = item.previewColors;
    const grad = cols.length >= 2
      ? `linear-gradient(180deg,${cols[0]},${cols[cols.length-1]})`
      : cols[0];
    return `<div class="shop-preview-bg" style="background:${grad}"></div>`;
  }
  if (category === 'effects') {
    const shape = item.shape || 'circle';
    const cols = (item.previewColors || item.colors || []).slice(0, 4);
    const svgShapes = {
      circle: (c) => `<svg class="shop-preview-shape" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7" fill="${c}"/></svg>`,
      star: (c) => `<svg class="shop-preview-shape" viewBox="0 0 16 16"><polygon points="8,1 10,6 15,6 11,9.5 12.5,15 8,11.5 3.5,15 5,9.5 1,6 6,6" fill="${c}"/></svg>`,
      petal: (c) => `<svg class="shop-preview-shape" viewBox="0 0 16 16"><ellipse cx="8" cy="6" rx="4" ry="7" fill="${c}" transform="rotate(15,8,8)"/></svg>`,
      snowflake: (c) => `<svg class="shop-preview-shape" viewBox="0 0 16 16"><line x1="8" y1="1" x2="8" y2="15" stroke="${c}" stroke-width="1.5"/><line x1="1" y1="8" x2="15" y2="8" stroke="${c}" stroke-width="1.5"/><line x1="3" y1="3" x2="13" y2="13" stroke="${c}" stroke-width="1.2"/><line x1="13" y1="3" x2="3" y2="13" stroke="${c}" stroke-width="1.2"/></svg>`,
      square: (c) => `<svg class="shop-preview-shape" viewBox="0 0 16 16"><rect x="2" y="2" width="12" height="12" rx="2" fill="${c}"/></svg>`,
    };
    const gen = svgShapes[shape] || svgShapes.circle;
    const shapes = cols.map(c => gen(c)).join('');
    return `<div class="shop-preview-effects">${shapes}</div>`;
  }
  if (category === 'uiThemes') {
    const accent = (item.vars && item.vars['--accent']) || '#4facfe';
    const coin = (item.vars && item.vars['--coin-gold']) || '#FFD700';
    return `<div class="shop-preview-ui">
      <div class="shop-preview-ui-bar" style="background:${accent}"></div>
      <div class="shop-preview-ui-btn" style="background:${accent}"></div>
      <div class="shop-preview-ui-dot" style="background:${coin}"></div>
    </div>`;
  }
  // Fallback: swatches
  const src = item.colors || item.previewColors || [];
  const samples = (item.colors || []).slice(0, 6);
  if (samples.length > 0) {
    return samples.map(c => {
      const c0 = Array.isArray(c) ? c[0] : c;
      const c1 = Array.isArray(c) ? c[1] : c;
      return `<div class="shop-preview-swatch" style="background:linear-gradient(135deg,${c0},${c1})"></div>`;
    }).join('');
  }
  if (item.previewColors) {
    return item.previewColors.map(c =>
      `<div class="shop-preview-swatch" style="background:${c}"></div>`
    ).join('');
  }
  return '';
}

function getCategoryForTab(tab) { return tab; }

function openShop() {
  document.getElementById('shopScreen').classList.remove('hidden');
  document.getElementById('shopCoins').textContent = coinBalance;
  renderShopTab(currentShopTab);
}

function closeShop() {
  document.getElementById('shopScreen').classList.add('hidden');
  localStorage.setItem('tiltTower_lastShopVisit', getTodayDateStr());
  updateShopNotifyDot();
}

function renderShopTab(tab) {
  currentShopTab = tab;
  document.querySelectorAll('.shop-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  const grid = document.getElementById('shopGrid');
  const catalog = getCatalogForTab(tab);
  const category = getCategoryForTab(tab);
  const owned = ownedSkins[category] || [];
  const equipped = equippedSkins[category] || 'default';
  const rotation = getWeeklyRotation();
  const currentMonth = new Date().getMonth() + 1;

  // Rotation section
  const rotSection = document.getElementById('shopRotationSection');
  const rotGrid = document.getElementById('shopRotationGrid');
  const rotItems = [];
  for (const [id, item] of Object.entries(catalog)) {
    if (item.rotation && rotation.includes(id) && !owned.includes(id)) {
      rotItems.push([id, item]);
    }
  }
  if (rotItems.length > 0) {
    rotSection.style.display = '';
    document.getElementById('rotationTimer').textContent = formatCountdown(getNextMondayMs());
    rotGrid.innerHTML = rotItems.map(([id, item]) => buildShopCard(id, item, category, owned, equipped)).join('');
  } else {
    rotSection.style.display = 'none';
  }

  // Main grid
  let html = '';
  for (const [id, item] of Object.entries(catalog)) {
    if (item.seasonal && item.seasonal.month !== currentMonth && !owned.includes(id)) continue;
    if (item.rotation && !rotation.includes(id) && !owned.includes(id)) continue;
    html += buildShopCard(id, item, category, owned, equipped);
  }
  grid.innerHTML = html;

  // Ownership count
  const totalAvailable = Object.keys(catalog).length;
  document.getElementById('shopOwnCount').textContent = `${owned.length}/${totalAvailable} ÊâÄÊåÅ‰∏≠`;
}

function buildShopCard(id, item, category, owned, equipped) {
  const isOwned = owned.includes(id);
  const isEquipped = equipped === id;
  const canAfford = coinBalance >= item.price;
  const rotation = getWeeklyRotation();

  let badge = '';
  if (item.rotation && rotation.includes(id) && !isOwned) badge = '<div class="shop-card-badge">LIMITED</div>';
  else if (item.seasonal && !isOwned) badge = '<div class="shop-card-badge seasonal">Â≠£ÁØÄÈôêÂÆö</div>';

  const preview = generatePreview(item, category);

  let priceHTML, btnHTML;
  if (item.price === 0) {
    priceHTML = '<div class="shop-card-price">ÁÑ°Êñô</div>';
    btnHTML = isEquipped
      ? '<button class="shop-card-btn equipped-btn">‚úì Ë£ÖÂÇô‰∏≠</button>'
      : `<button class="shop-card-btn equip" onclick="equipSkin('${category}','${id}')">Ë£ÖÂÇô„Åô„Çã</button>`;
  } else if (isOwned) {
    priceHTML = '<div class="shop-card-price">ÊâÄÊåÅ‰∏≠</div>';
    btnHTML = isEquipped
      ? '<button class="shop-card-btn equipped-btn">‚úì Ë£ÖÂÇô‰∏≠</button>'
      : `<button class="shop-card-btn equip" onclick="equipSkin('${category}','${id}')">Ë£ÖÂÇô„Åô„Çã</button>`;
  } else {
    priceHTML = `<div class="shop-card-price ${canAfford ? '' : 'insufficient'}">ü™ô ${item.price}</div>`;
    btnHTML = canAfford
      ? `<button class="shop-card-btn buy" onclick="showPurchaseDialog('${category}','${id}')">Ë≥ºÂÖ•</button>`
      : '<button class="shop-card-btn buy" disabled>„Ç≥„Ç§„É≥‰∏çË∂≥</button>';
  }

  return `<div class="shop-card ${isEquipped ? 'equipped' : ''}">
    ${badge}
    <div class="shop-preview">${preview}</div>
    <div class="shop-card-name">${item.name}</div>
    ${priceHTML}
    ${btnHTML}
  </div>`;
}

function showPurchaseDialog(category, id) {
  const catalog = getCatalogForTab(category);
  const item = catalog[id];
  if (!item) return;
  pendingPurchase = { category, id, item };

  document.getElementById('purchaseItemName').textContent = item.name;
  const previewEl = document.getElementById('purchasePreview');
  previewEl.innerHTML = generatePreview(item, category);
  document.getElementById('purchasePrice').textContent = `ü™ô ${item.price}`;
  document.getElementById('purchaseBalance').textContent = `ÊÆãÈ´ò: ü™ô ${coinBalance} ‚Üí ${coinBalance - item.price}`;
  document.getElementById('purchaseDialog').classList.remove('hidden');
}

function closePurchaseDialog() {
  document.getElementById('purchaseDialog').classList.add('hidden');
  pendingPurchase = null;
}

function confirmPurchase() {
  if (!pendingPurchase) return;
  const { category, id, item } = pendingPurchase;
  if (coinBalance < item.price) return;
  coinBalance -= item.price;
  saveCoins();
  if (!ownedSkins[category]) ownedSkins[category] = ['default'];
  ownedSkins[category].push(id);
  saveInventory();
  sfxPurchase();
  vibrate([20, 30, 60]);
  closePurchaseDialog();
  document.getElementById('shopCoins').textContent = coinBalance;
  renderShopTab(currentShopTab);
  updateCoinDisplay();
}

function equipSkin(category, id) {
  equippedSkins[category] = id;
  saveInventory();
  sfxEquip();
  vibrate(15);
  if (category === 'uiThemes') applyUiTheme(id);
  document.getElementById('shopCoins').textContent = coinBalance;
  renderShopTab(currentShopTab);
}

function applyUiTheme(themeId) {
  const theme = UI_THEMES[themeId];
  // Reset to defaults first
  const defaults = {'--accent':'','--accent-glow':'','--coin-gold':'','--coin-glow':''};
  for (const key of Object.keys(defaults)) {
    document.documentElement.style.removeProperty(key);
  }
  if (theme && theme.vars) {
    for (const [k, v] of Object.entries(theme.vars)) {
      document.documentElement.style.setProperty(k, v);
    }
  }
}

// Apply saved UI theme on load
applyUiTheme(equippedSkins.uiThemes);

// ===== SFX: Purchase & Equip =====
function sfxPurchase() {
  playTone('sine', 523, 80, 0.15);
  setTimeout(() => playTone('sine', 659, 80, 0.15), 60);
  setTimeout(() => playTone('sine', 784, 80, 0.18), 120);
  setTimeout(() => playTone('sine', 1047, 200, 0.2), 180);
}

function sfxEquip() {
  playTone('sine', 880, 60, 0.12);
  setTimeout(() => playTone('triangle', 1100, 100, 0.15), 50);
}

// ===== Shop Notification Dot =====
function updateShopNotifyDot() {
  const dot = document.getElementById('shopNotifyDot');
  if (!dot) return;
  const lastVisit = localStorage.getItem('tiltTower_lastShopVisit') || '';
  const lastRotation = localStorage.getItem('tiltTower_lastSeenRotation') || '';
  const now = new Date();
  const currentWeek = now.getFullYear() + '-W' + getISOWeek(now);
  const hasNewRotation = lastRotation !== currentWeek;
  const hasNewSeasonal = checkNewSeasonalItems();
  dot.classList.toggle('show', hasNewRotation || hasNewSeasonal);
}

function checkNewSeasonalItems() {
  const month = new Date().getMonth() + 1;
  const cats = [BLOCK_SKINS, BG_THEMES, EFFECT_SKINS, UI_THEMES];
  const catKeys = ['blocks', 'backgrounds', 'effects', 'uiThemes'];
  for (let i = 0; i < cats.length; i++) {
    for (const [id, item] of Object.entries(cats[i])) {
      if (item.seasonal && item.seasonal.month === month && !ownedSkins[catKeys[i]].includes(id)) return true;
    }
  }
  return false;
}

// ===== FOMO Text =====
function updateFomoText() {
  const fomoEl = document.getElementById('startFomo');
  if (!fomoEl) return;
  const rotation = getWeeklyRotation();
  const hasUnowned = rotation.some(id => {
    for (const cat of ['blocks','backgrounds','effects','uiThemes']) {
      if (!ownedSkins[cat].includes(id)) return true;
    }
    return false;
  });
  if (hasUnowned) {
    fomoEl.textContent = '‰ªäÈÄ±„ÅÆÈôêÂÆö„Ç¢„Ç§„ÉÜ„É†„ÅåÁµÇ„Çè„ÇãÂâç„Å´„Ç≤„ÉÉ„Éà„Åó„Çà„ÅÜ!';
    fomoEl.style.display = '';
  } else {
    fomoEl.style.display = 'none';
  }
}

// ===== Start Screen Equipped Preview =====
function updateEquippedPreview() {
  const row = document.getElementById('startEquippedRow');
  if (!row) return;
  const skinId = equippedSkins.blocks;
  const skin = BLOCK_SKINS[skinId] || BLOCK_SKINS.default;
  row.innerHTML = skin.colors.slice(0, 5).map(c => {
    const c0 = Array.isArray(c) ? c[0] : c;
    const c1 = Array.isArray(c) ? c[1] : c;
    return `<div class="start-equipped-swatch" style="background:linear-gradient(135deg,${c0},${c1})"></div>`;
  }).join('');
}

function getBlockColor(i) {
  const skinId = equippedSkins.blocks;
  const skin = BLOCK_SKINS[skinId] || BLOCK_SKINS.default;
  return skin.colors[i % skin.colors.length];
}

function vibrate(pattern) {
  if (vibrationSupported && vibrationEnabled) navigator.vibrate(pattern);
}

// ===== Background Color Stages =====
function getBgColors(blockCount) {
  const isDark = !document.documentElement.classList.contains('light');
  const themeId = equippedSkins.backgrounds;
  const theme = BG_THEMES[themeId] || BG_THEMES.default;
  const stages = isDark ? theme.darkStages : theme.lightStages;
  const idx = Math.min(Math.floor(blockCount / 10), stages.length - 1);
  const next = Math.min(idx + 1, stages.length - 1);
  const frac = (blockCount % 10) / 10;
  return {
    top: lerpColor(stages[idx].t, stages[next].t, frac),
    bot: lerpColor(stages[idx].b, stages[next].b, frac),
    stars: blockCount >= 25,
    overlay: theme.overlay,
  };
}

function lerpColor(c1, c2, t) {
  const r1 = parseInt(c1.slice(1,3),16), g1 = parseInt(c1.slice(3,5),16), b1 = parseInt(c1.slice(5,7),16);
  const r2 = parseInt(c2.slice(1,3),16), g2 = parseInt(c2.slice(3,5),16), b2 = parseInt(c2.slice(5,7),16);
  const r = Math.round(r1 + (r2-r1)*t), g = Math.round(g1 + (g2-g1)*t), b = Math.round(b1 + (b2-b1)*t);
  return `rgb(${r},${g},${b})`;
}

// ===== Stars (for space stage) =====
let stars = [];
function generateStars() {
  stars = [];
  const count = isMobile ? 25 : 60;
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random(), y: Math.random(),
      size: 0.5 + Math.random() * 1.5,
      alpha: 0.3 + Math.random() * 0.5,
      twinkleSpeed: 0.6 + Math.random() * 1.2, // pre-scaled
      phase: Math.random() * Math.PI * 2,
    });
  }
}
generateStars();

// ===== Init =====
function init() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);

  // Buttons
  document.getElementById('startBtn').addEventListener('click', () => { sfxButton(); requestMotionAndStart(); });
  document.getElementById('retryBtn').addEventListener('click', () => { sfxButton(); startGame(); });
  document.getElementById('permissionBtn').addEventListener('click', () => { sfxButton(); grantPermission(); });

  checkDailyStreakStatus();
  updateStartScreen();

  // Name prompt
  if (!playerName) {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('namePrompt').classList.remove('hidden');
  }
  document.getElementById('nameOkBtn').addEventListener('click', () => { sfxButton(); submitName(); });
  document.getElementById('nameInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submitName();
  });

  // Settings
  document.getElementById('settingsBtn').addEventListener('click', () => { sfxButton(); openSettings(); });
  document.getElementById('settingsCloseBtn').addEventListener('click', () => { sfxButton(); closeSettings(); });

  // Shop
  document.getElementById('shopBtn').addEventListener('click', () => { sfxButton(); openShop(); });
  document.getElementById('shopBackBtn').addEventListener('click', () => { sfxButton(); closeShop(); });
  document.querySelectorAll('.shop-tab').forEach(tab => {
    tab.addEventListener('click', () => { sfxButton(); renderShopTab(tab.dataset.tab); });
  });
  document.getElementById('purchaseCancelBtn').addEventListener('click', () => { sfxButton(); closePurchaseDialog(); });
  document.getElementById('purchaseConfirmBtn').addEventListener('click', () => { confirmPurchase(); });

  // Ranking
  document.getElementById('rankingBtn').addEventListener('click', () => { sfxButton(); openLeaderboard(); });
  document.getElementById('goRankingBtn').addEventListener('click', () => { sfxButton(); openLeaderboard(); });
  document.getElementById('goHomeBtn').addEventListener('click', () => { sfxButton(); goHome(); });
  document.getElementById('lbBackBtn').addEventListener('click', () => { sfxButton(); closeLeaderboard(); });
  document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
    document.getElementById('sensitivityVal').textContent = parseFloat(e.target.value).toFixed(1);
  });

  // Theme buttons
  document.querySelectorAll('.theme-opt').forEach(btn => {
    btn.addEventListener('click', () => {
      sfxButton();
      document.querySelectorAll('.theme-opt').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    });
  });

  // Sound toggle
  document.getElementById('soundToggle').classList.toggle('on', soundEnabled);
  document.getElementById('soundToggle').addEventListener('click', () => {
    const toggle = document.getElementById('soundToggle');
    toggle.classList.toggle('on');
    soundEnabled = toggle.classList.contains('on');
    if (soundEnabled) { initAudio(); sfxButton(); }
  });

  // Vibration toggle
  if (vibrationSupported) {
    document.getElementById('vibrationGroup').style.display = '';
    document.getElementById('vibrationToggle').classList.toggle('on', vibrationEnabled);
  }
  document.getElementById('vibrationToggle').addEventListener('click', () => {
    const toggle = document.getElementById('vibrationToggle');
    toggle.classList.toggle('on');
    if (toggle.classList.contains('on') && vibrationSupported) navigator.vibrate(50);
  });

  // Share
  document.getElementById('shareBtn').addEventListener('click', () => { sfxButton(); shareScore(); });

  // Desktop fallback
  setupDesktopFallback();

  // Loop
  requestAnimationFrame(loop);
}

function submitName() {
  const input = document.getElementById('nameInput');
  const name = input.value.trim();
  if (!name) return;
  playerName = name;
  localStorage.setItem('tiltTowerName', playerName);
  reserveName(playerName);
  document.getElementById('namePrompt').classList.add('hidden');
  document.getElementById('startScreen').classList.remove('hidden');
  updateStartScreen();
}

function updateStartScreen() {
  const bestEl = document.getElementById('startBest');
  const greetEl = document.getElementById('startGreeting');
  bestEl.textContent = bestScoreVal > 0 ? `BEST: ${bestScoreVal}` : '';
  if (playerName) {
    greetEl.innerHTML = `„Åä„Åã„Åà„Çä„ÄÅ<span class="name">${playerName}</span>„Åï„Çì`;
  } else {
    greetEl.textContent = '';
  }
  updateCoinDisplay();
  updateDailyBonusCard();
  updateEquippedPreview();
  updateFomoText();
  updateShopNotifyDot();
}

function openSettings() {
  document.getElementById('settingsName').value = playerName;
  document.getElementById('sensitivitySlider').value = TILT_SENSITIVITY;
  document.getElementById('sensitivityVal').textContent = TILT_SENSITIVITY.toFixed(1);
  // Theme
  const curTheme = localStorage.getItem('tiltTowerTheme') || 'auto';
  document.querySelectorAll('.theme-opt').forEach(b => {
    b.classList.toggle('active', b.dataset.theme === curTheme);
  });
  // Toggles
  document.getElementById('soundToggle').classList.toggle('on', soundEnabled);
  if (vibrationSupported) {
    document.getElementById('vibrationToggle').classList.toggle('on', vibrationEnabled);
  }
  document.getElementById('settingsScreen').classList.remove('hidden');
}

function closeSettings() {
  const name = document.getElementById('settingsName').value.trim();
  if (name) {
    playerName = name;
    localStorage.setItem('tiltTowerName', playerName);
    reserveName(playerName);
  }
  TILT_SENSITIVITY = parseFloat(document.getElementById('sensitivitySlider').value);
  localStorage.setItem('tiltTowerSensitivity', TILT_SENSITIVITY.toFixed(1));
  // Theme
  const activeTheme = document.querySelector('.theme-opt.active');
  const themeVal = activeTheme ? activeTheme.dataset.theme : 'auto';
  localStorage.setItem('tiltTowerTheme', themeVal);
  applyTheme(themeVal);
  // Sound
  soundEnabled = document.getElementById('soundToggle').classList.contains('on');
  localStorage.setItem('tiltTowerSound', soundEnabled ? 'on' : 'off');
  // Vibration
  if (vibrationSupported) {
    vibrationEnabled = document.getElementById('vibrationToggle').classList.contains('on');
    localStorage.setItem('tiltTowerVibration', vibrationEnabled ? 'on' : 'off');
  }
  document.getElementById('settingsScreen').classList.add('hidden');
  updateStartScreen();
}

function shareScore() {
  const placedCount = blocks.length - 1;
  const heightM = (placedCount * BLOCK_HEIGHT / 100).toFixed(1);
  const text = `${playerName}„ÅØ${heightM}m„Åæ„ÅßÁ©ç„Çì„Å†ÔºÅÔºà„Çπ„Ç≥„Ç¢: ${score}Ôºâü™ô${coinBalance}\nhttps://mikan-atomoki.github.io/phone-stackgame/`;
  if (navigator.share) {
    navigator.share({ text }).catch(() => {});
  } else {
    navigator.clipboard.writeText(text).then(() => {
      const toast = document.getElementById('shareToast');
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }).catch(() => {});
  }
}

function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// ===== Motion Permission =====
function requestMotionAndStart() {
  initAudio();
  resumeAudio();
  if (typeof DeviceOrientationEvent !== 'undefined' &&
      typeof DeviceOrientationEvent.requestPermission === 'function') {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('permissionPrompt').classList.remove('hidden');
  } else if (window.DeviceOrientationEvent) {
    enableMotion();
    startGame();
  } else {
    usingMouse = true;
    startGame();
  }
}

function grantPermission() {
  DeviceOrientationEvent.requestPermission().then(state => {
    document.getElementById('permissionPrompt').classList.add('hidden');
    if (state === 'granted') enableMotion();
    else usingMouse = true;
    startGame();
  }).catch(() => {
    document.getElementById('permissionPrompt').classList.add('hidden');
    usingMouse = true;
    startGame();
  });
}

function enableMotion() {
  hasMotionPermission = true;
  window.addEventListener('deviceorientation', (e) => {
    const gamma = e.gamma || 0;
    tiltX = Math.max(-1, Math.min(1, gamma / 30));
  });
}

function setupDesktopFallback() {
  window.addEventListener('mousemove', (e) => {
    if (!hasMotionPermission) {
      usingMouse = true;
      tiltX = Math.max(-1, Math.min(1, (e.clientX - W / 2) / (W * 0.35)));
    }
  });
  window.addEventListener('touchmove', (e) => {
    if (!hasMotionPermission && e.touches.length > 0) {
      usingMouse = true;
      tiltX = Math.max(-1, Math.min(1, (e.touches[0].clientX - W / 2) / (W * 0.35)));
    }
  }, { passive: true });
}

function goHome() {
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('hudCoins').style.display = 'none';
  document.getElementById('tiltIndicator').style.display = 'none';
  document.getElementById('comboGauge').classList.remove('show');
  document.getElementById('startScreen').classList.remove('hidden');
  gameState = 'start';
  updateStartScreen();
}

// ===== Game Logic =====
function startGame() {
  initAudio();
  resumeAudio();
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('hudCoins').style.display = '';
  document.getElementById('tiltIndicator').style.display = 'flex';
  document.getElementById('comboGauge').classList.remove('show');
  updateCoinDisplay();

  score = 0;
  blocks = [];
  particles = [];
  textParticles = [];
  bgOverlayParticles = [];
  comboCount = 0;
  peakCombo = 0;
  dropSpeed = DROP_SPEED_INIT;
  cameraY = 0;
  targetCameraY = 0;
  shakeAmount = 0;
  freezeFrames = 0;
  milestoneText = '';
  milestoneTimer = 0;
  consecutiveMisses = 0;

  blocks.push({
    x: W / 2, y: H - 60,
    w: INITIAL_BLOCK_WIDTH + 40, h: BLOCK_HEIGHT,
    color: ['#555', '#777'], isBase: true,
  });

  spawnBlock();
  gameState = 'playing';
  updateHUD();
  updateComboGauge();
}

function spawnBlock() {
  const prev = blocks[blocks.length - 1];
  const level = blocks.length - 1;
  const widthShrink = Math.max(0, level * 2);
  let newWidth = Math.max(MIN_BLOCK_WIDTH, Math.min(prev.w, INITIAL_BLOCK_WIDTH - widthShrink));

  // Adaptive difficulty: widen block slightly after consecutive misses
  if (consecutiveMisses >= 3) {
    newWidth = Math.min(prev.w, newWidth + consecutiveMisses * 3);
  }

  const spread = Math.min(W * 0.4, 60 + level * 8);
  // Adaptive: reduce spread when struggling
  const adaptedSpread = consecutiveMisses >= 3 ? spread * 0.7 : spread;
  const offsetX = (Math.random() - 0.5) * 2 * adaptedSpread;
  const spawnX = Math.max(newWidth / 2, Math.min(W - newWidth / 2, prev.x + offsetX));

  // Adaptive: slow down slightly when struggling
  const adaptedSpeed = consecutiveMisses >= 3 ? dropSpeed * 0.85 : dropSpeed;

  // Bonus block: ~12% chance after 5 blocks (variable ratio)
  const isBonus = level >= 5 && Math.random() < 0.12;

  currentBlock = {
    x: spawnX, y: prev.y - 250,
    w: newWidth, h: BLOCK_HEIGHT,
    vy: adaptedSpeed,
    color: isBonus ? ['#FFD700', '#FFA500'] : getBlockColor(blocks.length),
    placed: false,
    squish: 0,
    isBonus: isBonus,
  };
}

function placeBlock() {
  if (!currentBlock || currentBlock.placed) return;

  const prev = blocks[blocks.length - 1];
  currentBlock.y = prev.y - prev.h / 2 - currentBlock.h / 2;

  const dx = currentBlock.x - prev.x;
  const overlap = getOverlap(currentBlock, prev);

  if (overlap <= 0) {
    gameOver();
    return;
  }

  const overlapCenter = getOverlapCenter(currentBlock, prev);
  const isPerfect = Math.abs(dx) < PERFECT_THRESHOLD;
  let pointsEarned = 0;

  if (isPerfect) {
    comboCount++;
    if (comboCount > peakCombo) peakCombo = comboCount;
    pointsEarned = 100 + comboCount * 50;
    score += pointsEarned;
    spawnPerfectParticles(currentBlock);
    currentBlock.w = Math.min(currentBlock.w + 4, prev.w);
    vibrate([20, 40, 20]);
    sfxPerfect(comboCount);
    freezeFrames = 3;
    consecutiveMisses = 0;
  } else {
    comboCount = 0;
    currentBlock.x = overlapCenter;
    currentBlock.w = overlap;
    pointsEarned = Math.round(overlap / 2);
    score += pointsEarned;
    vibrate(15);
    sfxPlace();
    spawnSliceParticles(currentBlock, prev, dx);
    // Track misses for adaptive difficulty (low overlap = miss)
    if (overlap < prev.w * 0.5) {
      consecutiveMisses++;
    } else {
      consecutiveMisses = Math.max(0, consecutiveMisses - 1);
    }
  }

  // Bonus block reward
  if (currentBlock.isBonus) {
    const bonus = 200;
    pointsEarned += bonus;
    score += bonus;
    sfxBonus();
    vibrate([20, 20, 20, 20, 40]);
    spawnScoreText(currentBlock.x, currentBlock.y - 20, bonus, true);
    // Extra sparkle particles
    const sparkleCount = Math.round(10 * PARTICLE_MULT);
    for (let i = 0; i < sparkleCount; i++) {
      addParticle({
        x: currentBlock.x + (Math.random() - 0.5) * currentBlock.w,
        y: currentBlock.y,
        vx: (Math.random() - 0.5) * 5,
        vy: -Math.random() * 6 - 1,
        life: 1, decay: 0.015 + Math.random() * 0.008,
        size: 2 + Math.random() * 4,
        color: ['#FFD700','#FFA500','#FFE066'][Math.floor(Math.random()*3)],
      });
    }
  }

  // Squish animation
  currentBlock.squish = 1.0;
  currentBlock.placed = true;
  blocks.push(currentBlock);

  // Score popup
  spawnScoreText(currentBlock.x, currentBlock.y, pointsEarned, isPerfect);

  // Camera
  targetCameraY = Math.max(0, (H - 60) - currentBlock.y - H * 0.55);

  // Speed up
  dropSpeed += DROP_SPEED_INCREMENT;

  if (currentBlock.w < MIN_BLOCK_WIDTH) {
    gameOver();
    return;
  }

  // Milestone check
  const placed = blocks.length - 1;
  if (placed > 0 && placed % 10 === 0) {
    milestoneText = `${placed} BLOCKS!`;
    milestoneTimer = 90;
    sfxMilestone();
    vibrate([20, 20, 40, 20, 80]);
    // Particle burst
    const burstCount = Math.round(15 * PARTICLE_MULT);
    for (let i = 0; i < burstCount; i++) {
      addParticle({
        x: W / 2 + (Math.random() - 0.5) * W * 0.5,
        y: currentBlock.y,
        vx: (Math.random() - 0.5) * 6,
        vy: -Math.random() * 6 - 2,
        life: 1, decay: 0.015 + Math.random() * 0.01,
        size: 3 + Math.random() * 5,
        color: ['#ffe066','#ff6b6b','#4facfe','#34d399','#e879f9'][Math.floor(Math.random()*5)],
      });
    }
  }
  // Height milestone
  const heightM = placed * BLOCK_HEIGHT / 100;
  if (heightM > 0 && heightM % 2 < BLOCK_HEIGHT / 100 && placed > 1) {
    const hm = Math.floor(heightM);
    if (hm > 0 && hm % 2 === 0 && milestoneTimer <= 0) {
      milestoneText = `${hm}.0m!`;
      milestoneTimer = 70;
    }
  }

  updateHUD();
  updateComboGauge();
  spawnBlock();
}

function getOverlap(a, b) {
  const aL = a.x - a.w / 2, aR = a.x + a.w / 2;
  const bL = b.x - b.w / 2, bR = b.x + b.w / 2;
  return Math.max(0, Math.min(aR, bR) - Math.max(aL, bL));
}

function getOverlapCenter(a, b) {
  const aL = a.x - a.w / 2, aR = a.x + a.w / 2;
  const bL = b.x - b.w / 2, bR = b.x + b.w / 2;
  return (Math.max(aL, bL) + Math.min(aR, bR)) / 2;
}

function gameOver() {
  gameState = 'gameover';
  shakeAmount = 15;
  vibrate([80, 60, 150]);
  sfxGameOver();

  const placedCount = blocks.length - 1;
  const heightM = (placedCount * BLOCK_HEIGHT / 100).toFixed(1);
  const isNewBest = score > bestScoreVal;
  if (isNewBest) {
    bestScoreVal = score;
    localStorage.setItem('tiltTowerBest', bestScoreVal);
  }

  setTimeout(() => {
    if (isNewBest) {
      sfxNewBest();
      spawnConfetti();
    }

    document.getElementById('hud').style.display = 'none';
    document.getElementById('hudCoins').style.display = 'none';
    document.getElementById('tiltIndicator').style.display = 'none';
    document.getElementById('comboGauge').classList.remove('show');

    // Positive title based on performance
    const titleEl = document.getElementById('gameOverTitle');
    if (isNewBest) { titleEl.textContent = 'NEW RECORD!'; titleEl.style.color = '#ffe066'; }
    else if (placedCount >= 20) { titleEl.textContent = 'AMAZING TOWER!'; titleEl.style.color = '#ffe066'; }
    else if (placedCount >= 10) { titleEl.textContent = 'NICE TOWER!'; titleEl.style.color = '#ffe066'; }
    else if (placedCount >= 5) { titleEl.textContent = 'GOOD TRY!'; titleEl.style.color = '#4facfe'; }
    else { titleEl.textContent = 'NICE TRY!'; titleEl.style.color = '#4facfe'; }

    document.getElementById('heightDisplay').textContent = `${placedCount} blocks (${heightM}m)`;
    document.getElementById('finalScore').textContent = score;

    // Peak moment
    const peakEl = document.getElementById('peakMoment');
    if (peakCombo >= 2) {
      peakEl.textContent = `Best combo: PERFECT x${peakCombo}!`;
    } else if (placedCount >= 5) {
      peakEl.textContent = `${heightM}m „ÅÆÂ°î„ÇíÂª∫„Å¶„ÅüÔºÅ`;
    } else {
      peakEl.textContent = '';
    }

    // Near best (Zeigarnik effect)
    const nearBestEl = document.getElementById('nearBest');
    if (!isNewBest && bestScoreVal > 0) {
      const diff = bestScoreVal - score;
      if (diff <= 300 && diff > 0) {
        nearBestEl.textContent = `„ÅÇ„Å® ${diff} ÁÇπ„Åß„Éô„Çπ„ÉàÊõ¥Êñ∞ÔºÅ`;
      } else {
        const bestBlocks = Math.ceil(diff / 80); // rough estimate
        if (bestBlocks <= 5 && bestBlocks > 0) {
          nearBestEl.textContent = `„ÅÇ„Å®Á¥Ñ ${bestBlocks} „Éñ„É≠„ÉÉ„ÇØ„Åß„Éô„Çπ„ÉàÊõ¥Êñ∞ÔºÅ`;
        } else {
          nearBestEl.textContent = '';
        }
      }
    } else {
      nearBestEl.textContent = '';
    }

    const newBestBadge = document.getElementById('newBestBadge');
    if (isNewBest) {
      newBestBadge.classList.add('show');
      document.getElementById('bestScore').textContent = '';
    } else {
      newBestBadge.classList.remove('show');
      document.getElementById('bestScore').textContent = `BEST: ${bestScoreVal}`;
    }
    // Coin reward
    const rawCoins = calculateCoinsEarned(score, peakCombo);
    const streakMult = getStreakMultiplier();
    const earnedCoins = Math.max(1, Math.round(rawCoins * streakMult));
    addCoins(earnedCoins);
    document.getElementById('coinEarnedVal').textContent = earnedCoins;
    const coinRewardEl = document.getElementById('coinReward');
    coinRewardEl.classList.remove('show');
    const streakMultEl = document.getElementById('streakMultiplier');
    streakMultEl.textContent = streakMult > 1.0 ? `(„Çπ„Éà„É™„Éº„ÇØ x${streakMult.toFixed(1)})` : '';
    setTimeout(() => {
      coinRewardEl.classList.add('show');
      sfxCoinEarn();
    }, 300);

    document.getElementById('gameOverScreen').classList.remove('hidden');
    updateStartScreen();

    // Firebase: submit score with feedback
    const rankSection = document.getElementById('rankingSubmitSection');
    if (isNewBest && playerName) {
      rankSection.innerHTML = '‚è≥ „É©„É≥„Ç≠„É≥„Ç∞ÈÄÅ‰ø°‰∏≠...';
      submitScore(score, placedCount, peakCombo).then(ok => {
        if (ok) {
          rankSection.innerHTML = '<span style="color:#2ecc71">‚úì „É©„É≥„Ç≠„É≥„Ç∞„Å´ÁôªÈå≤„Åó„Åæ„Åó„ÅüÔºÅ</span>';
        } else {
          rankSection.innerHTML = '<span style="color:#ff4757">ÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</span> <button class="ranking-retry-btn" id="rankingRetryBtn">ÂÜçË©¶Ë°å</button>';
          document.getElementById('rankingRetryBtn').addEventListener('click', () => {
            rankSection.innerHTML = '‚è≥ „É©„É≥„Ç≠„É≥„Ç∞ÈÄÅ‰ø°‰∏≠...';
            submitScore(score, placedCount, peakCombo).then(ok2 => {
              rankSection.innerHTML = ok2
                ? '<span style="color:#2ecc71">‚úì „É©„É≥„Ç≠„É≥„Ç∞„Å´ÁôªÈå≤„Åó„Åæ„Åó„ÅüÔºÅ</span>'
                : '<span style="color:#ff4757">ÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</span>';
            });
          });
        }
      });
    } else if (isNewBest && !playerName) {
      rankSection.innerHTML = '<span class="ranking-name-link" id="rankingSetName">ÂêçÂâç„ÇíË®≠ÂÆö</span>„Åô„Çã„Å®„É©„É≥„Ç≠„É≥„Ç∞„Å´ÁôªÈå≤„Åß„Åç„Åæ„Åô';
      document.getElementById('rankingSetName').addEventListener('click', () => {
        sfxButton();
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('namePrompt').classList.remove('hidden');
      });
    } else {
      rankSection.innerHTML = '';
    }
  }, 800);
}

// ===== Combo Gauge =====
function updateComboGauge() {
  const gauge = document.getElementById('comboGauge');
  const fill = document.getElementById('comboFill');
  const label = document.getElementById('comboLabel');

  if (comboCount < 2) {
    gauge.classList.remove('show');
    return;
  }
  gauge.classList.add('show');

  const tiers = [
    { min: 2, pct: 25, color: '#4facfe', name: 'COMBO x' },
    { min: 3, pct: 45, color: '#a855f7', name: 'COMBO x' },
    { min: 5, pct: 70, color: '#f59e0b', name: 'COMBO x' },
    { min: 8, pct: 100, color: 'linear-gradient(90deg,#f00,#f90,#ff0,#0f0,#0ff,#00f,#f0f)', name: 'COMBO x' },
  ];
  let tier = tiers[0];
  for (const t of tiers) {
    if (comboCount >= t.min) tier = t;
  }
  fill.style.width = tier.pct + '%';
  fill.style.background = tier.color;
  label.textContent = tier.name + comboCount;

  // Combo tier labels
  const names = [
    { min: 3, label: 'Nice!' },
    { min: 5, label: 'Great!' },
    { min: 8, label: 'Amazing!' },
    { min: 13, label: 'INCREDIBLE!' },
    { min: 21, label: 'LEGENDARY!' },
  ];
  for (const n of names) {
    if (comboCount >= n.min) label.textContent = `${n.label} x${comboCount}`;
  }
}

function updateHUD() {
  document.getElementById('scoreVal').textContent = score;
  document.getElementById('blockCount').textContent = blocks.length - 1;
  document.getElementById('heightVal').textContent = ((blocks.length - 1) * BLOCK_HEIGHT / 100).toFixed(1) + 'm';
}

// ===== Score Text Particles =====
function spawnScoreText(x, y, points, isPerfect) {
  addTextParticle({
    x, y,
    text: '+' + points,
    life: 1,
    decay: isPerfect ? 0.012 : 0.018,
    size: isPerfect ? 22 : 15,
    color: isPerfect ? '#ffe066' : '#fff',
    vy: -1.5,
  });
}

// ===== Confetti (NEW BEST) =====
function spawnConfetti() {
  const effSkin = EFFECT_SKINS[equippedSkins.effects] || EFFECT_SKINS.default;
  const colors = effSkin.colors.length > 0 ? effSkin.colors : ['#ff6b6b','#ffd93d','#4facfe','#34d399','#e879f9','#fb923c','#a78bfa'];
  const count = Math.round(40 * PARTICLE_MULT);
  for (let i = 0; i < count; i++) {
    addParticle({
      x: W * Math.random(),
      y: -20 - Math.random() * 100,
      vx: (Math.random() - 0.5) * 3,
      vy: 1 + Math.random() * 3,
      life: 1,
      decay: 0.008 + Math.random() * 0.006, // faster decay
      size: 3 + Math.random() * 5,
      color: colors[Math.floor(Math.random() * colors.length)],
      isConfetti: true,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 10,
      w: 4 + Math.random() * 4,
      h: 6 + Math.random() * 6,
    });
  }
}

// ===== Particles =====
function addParticle(p) {
  if (particles.length >= MAX_PARTICLES) {
    // Evict oldest (lowest life)
    let minIdx = 0, minLife = particles[0].life;
    for (let i = 1; i < particles.length; i++) {
      if (particles[i].life < minLife) { minLife = particles[i].life; minIdx = i; }
    }
    particles[minIdx] = p;
  } else {
    particles.push(p);
  }
}

function addTextParticle(t) {
  if (textParticles.length >= MAX_TEXT_PARTICLES) {
    let minIdx = 0, minLife = textParticles[0].life;
    for (let i = 1; i < textParticles.length; i++) {
      if (textParticles[i].life < minLife) { minLife = textParticles[i].life; minIdx = i; }
    }
    textParticles[minIdx] = t;
  } else {
    textParticles.push(t);
  }
}

function spawnPerfectParticles(block) {
  const count = Math.round(20 * PARTICLE_MULT);
  for (let i = 0; i < count; i++) {
    addParticle({
      x: block.x + (Math.random() - 0.5) * block.w,
      y: block.y,
      vx: (Math.random() - 0.5) * 4,
      vy: -Math.random() * 5 - 2,
      life: 1, decay: 0.015 + Math.random() * 0.01,
      size: 3 + Math.random() * 4,
      color: getEffectColor(),
      useEffectShape: true,
    });
  }
}

function spawnSliceParticles(block, prev, dx) {
  const side = dx > 0 ? 1 : -1;
  const edgeX = block.x + side * block.w / 2;
  const count = Math.round(8 * PARTICLE_MULT);
  for (let i = 0; i < count; i++) {
    addParticle({
      x: edgeX + side * Math.random() * 20,
      y: block.y + (Math.random() - 0.5) * block.h,
      vx: side * (1 + Math.random() * 2),
      vy: Math.random() * 2,
      life: 1, decay: 0.02 + Math.random() * 0.01,
      size: 2 + Math.random() * 3,
      color: block.color[0],
    });
  }
}

function updateParticles() {
  // Swap-and-pop: O(n) instead of O(n¬≤) splice
  let len = particles.length;
  for (let i = len - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (p.isConfetti) {
      p.vy += 0.02;
      p.vx *= 0.99;
      p.rot += p.rotV;
    } else {
      p.vy += 0.1;
    }
    p.life -= p.decay;
    if (p.life <= 0) {
      particles[i] = particles[len - 1];
      len--;
    }
  }
  particles.length = len;

  // Text particles: swap-and-pop
  let tLen = textParticles.length;
  for (let i = tLen - 1; i >= 0; i--) {
    const t = textParticles[i];
    t.y += t.vy;
    t.vy *= 0.98;
    t.life -= t.decay;
    if (t.life <= 0) {
      textParticles[i] = textParticles[tLen - 1];
      tLen--;
    }
  }
  textParticles.length = tLen;
}

// ===== Rendering =====
function drawBlock(block, camY) {
  const bx = block.x - block.w / 2;
  let by = block.y + camY;
  let bw = block.w;
  let bh = block.h;

  if (by + bh < -50 || by > H + 50) return;

  // Squish animation
  if (block.squish > 0) {
    const s = block.squish;
    const squishY = 1 - s * 0.3;  // scaleY: 0.7 ‚Üí 1
    const squishX = 1 + s * 0.15; // scaleX: 1.15 ‚Üí 1
    const centerY = by + bh / 2;
    bh *= squishY;
    bw *= squishX;
    by = centerY - bh / 2;
    block.squish *= 0.85;
    if (block.squish < 0.01) block.squish = 0;
  }

  const x = block.x - bw / 2;

  const grad = ctx.createLinearGradient(x, by, x + bw, by + bh);
  grad.addColorStop(0, block.color[0]);
  grad.addColorStop(1, block.color[1]);

  // Bonus block glow
  if (block.isBonus) {
    if (!isMobile) {
      ctx.save();
      ctx.shadowColor = '#FFD700';
      ctx.shadowBlur = 16 + Math.sin(Date.now() * 0.0067) * 6;
      ctx.fillStyle = 'rgba(255,215,0,0.3)';
      roundRect(x - 2, by - 2, bw + 4, bh + 4, 8);
      ctx.shadowBlur = 0;
      ctx.restore();
    } else {
      // Lightweight glow for mobile: just a colored rect
      ctx.fillStyle = 'rgba(255,215,0,0.2)';
      roundRect(x - 2, by - 2, bw + 4, bh + 4, 8);
    }
  }

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  roundRect(x + 2, by + 2, bw, bh, 6);

  // Block
  ctx.fillStyle = grad;
  roundRect(x, by, bw, bh, 6);

  // Highlight
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  roundRect(x + 2, by + 2, bw - 4, bh / 2 - 2, 4);

  // Subtle border
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(x + 6, by);
  ctx.lineTo(x + bw - 6, by);
  ctx.quadraticCurveTo(x + bw, by, x + bw, by + 6);
  ctx.lineTo(x + bw, by + bh - 6);
  ctx.quadraticCurveTo(x + bw, by + bh, x + bw - 6, by + bh);
  ctx.lineTo(x + 6, by + bh);
  ctx.quadraticCurveTo(x, by + bh, x, by + bh - 6);
  ctx.lineTo(x, by + 6);
  ctx.quadraticCurveTo(x, by, x + 6, by);
  ctx.closePath();
  ctx.stroke();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

function drawParticleShape(x, y, size, shape) {
  if (shape === 'star') {
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = (i * 4 * Math.PI / 5) - Math.PI / 2;
      const r = i === 0 ? size : size;
      ctx[i === 0 ? 'moveTo' : 'lineTo'](x + Math.cos(a) * r, y + Math.sin(a) * r);
      const a2 = a + 2 * Math.PI / 5;
      ctx.lineTo(x + Math.cos(a2) * (r * 0.4), y + Math.sin(a2) * (r * 0.4));
    }
    ctx.closePath(); ctx.fill();
  } else if (shape === 'petal') {
    ctx.save(); ctx.translate(x, y);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.5, size * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
    ctx.fill(); ctx.restore();
  } else if (shape === 'snowflake') {
    ctx.save(); ctx.translate(x, y);
    ctx.lineWidth = 1;
    ctx.strokeStyle = ctx.fillStyle;
    for (let i = 0; i < 3; i++) {
      const a = i * Math.PI / 3;
      ctx.beginPath();
      ctx.moveTo(-Math.cos(a) * size, -Math.sin(a) * size);
      ctx.lineTo(Math.cos(a) * size, Math.sin(a) * size);
      ctx.stroke();
    }
    ctx.restore();
  } else if (shape === 'square') {
    ctx.fillRect(x - size, y - size, size * 2, size * 2);
  } else {
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function getEffectShape() {
  const skin = EFFECT_SKINS[equippedSkins.effects] || EFFECT_SKINS.default;
  return skin.shape || 'circle';
}

function getEffectColor() {
  const skin = EFFECT_SKINS[equippedSkins.effects] || EFFECT_SKINS.default;
  return skin.colors[Math.floor(Math.random() * skin.colors.length)];
}

function drawParticles(camY) {
  const shape = getEffectShape();
  for (let i = 0, len = particles.length; i < len; i++) {
    const p = particles[i];
    const py = p.isConfetti ? p.y : p.y + camY;
    if (py < -20 || py > H + 20 || p.x < -20 || p.x > W + 20) continue;
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    if (p.isConfetti) {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot * 0.01745329);
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    } else if (p.useEffectShape) {
      drawParticleShape(p.x, py, p.size, shape);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, py, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

function drawTextParticles(camY) {
  ctx.textAlign = 'center';
  for (let i = 0, len = textParticles.length; i < len; i++) {
    const t = textParticles[i];
    const ty = t.y + camY;
    if (ty < -30 || ty > H + 30) continue;
    ctx.globalAlpha = t.life;
    ctx.fillStyle = t.color;
    const scale = 0.8 + t.life * 0.4;
    ctx.font = `bold ${Math.round(t.size * scale)}px 'Courier New', monospace`;
    // Shadow only on mobile if life > 0.5 (expensive)
    if (!isMobile && t.color === '#ffe066') {
      ctx.shadowColor = 'rgba(255,224,102,0.5)';
      ctx.shadowBlur = 8;
    }
    ctx.fillText(t.text, t.x, ty);
    if (ctx.shadowBlur) ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
}

function drawBackground(camY) {
  const placed = blocks.length - 1;
  const bg = getBgColors(Math.max(0, placed));

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, bg.top);
  grad.addColorStop(1, bg.bot);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Stars (space stage)
  if (bg.stars) {
    const time = Date.now() * 0.001;
    const PI2 = Math.PI * 2;
    ctx.fillStyle = '#fff';
    for (let i = 0, len = stars.length; i < len; i++) {
      const s = stars[i];
      const a = s.alpha * (0.5 + 0.5 * Math.sin(time * s.twinkleSpeed + s.phase));
      ctx.globalAlpha = a;
      ctx.beginPath();
      ctx.arc(s.x * W, s.y * H, s.size, 0, PI2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Grid
  const isDark = !document.documentElement.classList.contains('light');
  ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)';
  ctx.lineWidth = 1;
  const gridSize = 60;
  const offsetY = camY % gridSize;
  for (let y = offsetY; y < H; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }

  // Height markers
  ctx.fillStyle = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
  ctx.font = '10px sans-serif';
  const baseY = H - 60;
  for (let i = 1; i <= 50; i++) {
    const markerY = baseY - i * BLOCK_HEIGHT * 5 + camY;
    if (markerY > -20 && markerY < H + 20) {
      ctx.fillText(`${(i * 5 * BLOCK_HEIGHT / 100).toFixed(0)}m`, 8, markerY + 4);
      ctx.fillRect(0, markerY, W, 1);
    }
  }

  // Background overlay (bubbles, petals, snowfall, scanlines)
  if (bg.overlay) drawBgOverlay(bg.overlay, camY);
}

// ===== Background Overlay Effects =====
let bgOverlayParticles = [];
const MAX_BG_OVERLAY = isMobile ? 12 : 25;

// Scanline: offscreen canvas cache (1ÂõûÊèèÁîª ‚Üí ÊØé„Éï„É¨„Éº„É†drawImage)
let scanlineCanvas = null;
let scanlineCacheW = 0;
let scanlineCacheH = 0;

function getScanlineCanvas() {
  if (scanlineCanvas && scanlineCacheW === W && scanlineCacheH === H) return scanlineCanvas;
  scanlineCanvas = document.createElement('canvas');
  scanlineCanvas.width = W;
  scanlineCanvas.height = H;
  scanlineCacheW = W;
  scanlineCacheH = H;
  const sctx = scanlineCanvas.getContext('2d');
  sctx.fillStyle = '#000';
  for (let sy = 0; sy < H; sy += 3) {
    sctx.fillRect(0, sy, W, 1);
  }
  return scanlineCanvas;
}

function drawBgOverlay(type, camY) {
  // Scanlines: cached offscreen canvas, 1 drawImage per frame
  if (type === 'scanlines') {
    ctx.save();
    ctx.globalAlpha = 0.03;
    ctx.drawImage(getScanlineCanvas(), 0, 0);
    ctx.globalAlpha = 1;
    ctx.restore();
    return;
  }

  const time = Date.now() * 0.001;
  // Spawn if needed
  while (bgOverlayParticles.length < MAX_BG_OVERLAY) {
    bgOverlayParticles.push(spawnBgOverlayParticle(type));
  }
  ctx.save();
  for (let i = bgOverlayParticles.length - 1; i >= 0; i--) {
    const p = bgOverlayParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    if (type === 'petals') { p.x += Math.sin(time * 1.5 + p.phase) * 0.3; p.rot += p.rotV; }
    if (type === 'snowfall') { p.x += Math.sin(time + p.phase) * 0.2; p.rot += p.rotV; }
    if (type === 'bubbles') { p.x += Math.sin(time * 0.8 + p.phase) * 0.15; }
    // Reset if off screen
    if (p.y > H + 20 || p.y < -20 || p.x > W + 20 || p.x < -20) {
      bgOverlayParticles[i] = spawnBgOverlayParticle(type);
      continue;
    }
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    if (type === 'bubbles') {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = p.alpha * 0.5;
      ctx.stroke();
      ctx.globalAlpha = p.alpha * 0.15;
      ctx.fill();
    } else if (type === 'petals') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.beginPath();
      ctx.ellipse(0, 0, p.size * 1.5, p.size * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    } else if (type === 'snowfall') {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

function spawnBgOverlayParticle(type) {
  if (type === 'bubbles') return {
    x: Math.random() * W, y: H + Math.random() * 40,
    vx: 0, vy: -0.2 - Math.random() * 0.5,
    size: 2 + Math.random() * 6, alpha: 0.15 + Math.random() * 0.2,
    color: '#88ccff', phase: Math.random() * Math.PI * 2,
  };
  if (type === 'petals') return {
    x: Math.random() * W, y: -10 - Math.random() * 40,
    vx: 0.1 + Math.random() * 0.3, vy: 0.3 + Math.random() * 0.6,
    size: 2 + Math.random() * 3, alpha: 0.2 + Math.random() * 0.3,
    color: ['#ffb7c5','#ffc0cb','#ff69b4','#fff0f5'][Math.floor(Math.random()*4)],
    phase: Math.random() * Math.PI * 2, rot: Math.random() * Math.PI, rotV: 0.01 + Math.random() * 0.02,
  };
  if (type === 'snowfall') return {
    x: Math.random() * W, y: -10 - Math.random() * 40,
    vx: 0, vy: 0.2 + Math.random() * 0.4,
    size: 1 + Math.random() * 2.5, alpha: 0.3 + Math.random() * 0.4,
    color: '#fff', phase: Math.random() * Math.PI * 2, rot: 0, rotV: 0,
  };
  return { x: 0, y: 0, vx: 0, vy: 0, size: 0, alpha: 0, color: '#fff', phase: 0 };
}

function drawComboText(camY) {
  if (comboCount >= 2 && currentBlock) {
    const prev = blocks[blocks.length - 1];
    ctx.save();
    const size = Math.min(18 + comboCount * 2, 36);
    ctx.font = `bold ${size}px 'Segoe UI', sans-serif`;
    ctx.textAlign = 'center';

    // Color by tier
    let color = '#4facfe';
    if (comboCount >= 8) color = '#ffe066';
    else if (comboCount >= 5) color = '#f59e0b';
    else if (comboCount >= 3) color = '#a855f7';

    ctx.fillStyle = color;
    ctx.globalAlpha = 0.85;
    if (!isMobile) { ctx.shadowColor = color; ctx.shadowBlur = 12; }
    ctx.fillText(`PERFECT x${comboCount}!`, W / 2, prev.y + camY - 30);
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawMilestone() {
  if (milestoneTimer <= 0) return;
  milestoneTimer--;
  const progress = milestoneTimer / 90;
  ctx.save();
  ctx.globalAlpha = progress > 0.7 ? 1 : progress / 0.7;
  const scale = progress > 0.8 ? 1.2 - (progress - 0.8) * 1 : 1;
  ctx.font = `bold ${Math.round(28 * scale)}px 'Segoe UI', sans-serif`;
  ctx.fillStyle = '#ffe066';
  ctx.textAlign = 'center';
  if (!isMobile) { ctx.shadowColor = 'rgba(255,224,102,0.5)'; ctx.shadowBlur = 16; }
  ctx.fillText(milestoneText, W / 2, H * 0.35);
  ctx.shadowBlur = 0;
  ctx.restore();
}

let lastTiltPct = -1;
let tiltDotElCached = null;
function updateTiltIndicator() {
  const pct = ((tiltX + 1) * 50) | 0;
  if (pct === lastTiltPct) return;
  lastTiltPct = pct;
  (tiltDotElCached || (tiltDotElCached = document.getElementById('tiltDot'))).style.left = pct + '%';
}

// ===== Game Loop =====
function loop() {
  // Hitstop / freeze frame
  if (freezeFrames > 0) {
    freezeFrames--;
    requestAnimationFrame(loop);
    return;
  }

  // Camera
  cameraY += (targetCameraY - cameraY) * CAMERA_LERP;

  // Shake
  let shakeX = 0, shakeY = 0;
  if (shakeAmount > 0) {
    shakeX = (Math.random() - 0.5) * shakeAmount;
    shakeY = (Math.random() - 0.5) * shakeAmount;
    shakeAmount *= 0.9;
    if (shakeAmount < 0.5) shakeAmount = 0;
  }

  const camY = cameraY + shakeY;

  ctx.save();
  ctx.translate(shakeX, 0);

  drawBackground(camY);

  for (const b of blocks) drawBlock(b, camY);

  if (gameState === 'playing' && currentBlock && !currentBlock.placed) {
    currentBlock.x += tiltX * TILT_SENSITIVITY;
    currentBlock.x = Math.max(currentBlock.w / 2, Math.min(W - currentBlock.w / 2, currentBlock.x));
    currentBlock.y += currentBlock.vy;

    const prev = blocks[blocks.length - 1];
    const landY = prev.y - prev.h / 2 - currentBlock.h / 2;
    if (currentBlock.y >= landY) {
      currentBlock.y = landY;
      placeBlock();
    }

    if (currentBlock && !currentBlock.placed) {
      drawBlock(currentBlock, camY);
      // Guide line
      const isDark = !document.documentElement.classList.contains('light');
      ctx.setLineDash([4, 8]);
      ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(currentBlock.x, currentBlock.y + currentBlock.h / 2 + camY);
      ctx.lineTo(currentBlock.x, prev.y + camY);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  drawParticles(camY);
  drawTextParticles(camY);
  drawComboText(camY);
  drawMilestone();

  ctx.restore();

  updateParticles();
  updateTiltIndicator();

  requestAnimationFrame(loop);
}

// ===== Firebase Leaderboard (Lazy Load) =====
let firebaseApp = null;
let firebaseAuth = null;
let firebaseDb = null;
let firebaseUser = null;
let firebaseLoaded = false;
let firebaseLoading = false;

const FIREBASE_CONFIG = {
  apiKey: "AIzaSyCj3vTrUUlolXqmjvaZfUiGu6iil8kBFv0",
  authDomain: "stack-game-ranking.firebaseapp.com",
  projectId: "stack-game-ranking",
  storageBucket: "stack-game-ranking.firebasestorage.app",
  messagingSenderId: "990659666551",
  appId: "1:990659666551:web:11d5a4932e3c587868dc72"
};

async function loadFirebase() {
  if (firebaseLoaded || firebaseLoading) return firebaseLoaded;
  if (FIREBASE_CONFIG.apiKey === 'REPLACE_WITH_YOUR_API_KEY') {
    console.warn('Firebase not configured. Leaderboard disabled.');
    return false;
  }
  firebaseLoading = true;
  try {
    const [appModule, authModule, fsModule] = await Promise.all([
      import('https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js'),
      import('https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js'),
      import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js'),
    ]);
    firebaseApp = appModule.initializeApp(FIREBASE_CONFIG);
    firebaseAuth = authModule.getAuth(firebaseApp);
    firebaseDb = fsModule.getFirestore(firebaseApp);
    // Anonymous auth
    const result = await authModule.signInAnonymously(firebaseAuth);
    firebaseUser = result.user;
    firebaseLoaded = true;
    firebaseLoading = false;
    return true;
  } catch (e) {
    console.error('Firebase load error:', e);
    firebaseLoading = false;
    return false;
  }
}

async function submitScore(scoreVal, placedCount, peakComboVal) {
  if (!await loadFirebase()) return false;
  if (!firebaseUser || !playerName) return false;
  try {
    const fsModule = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
    const docRef = fsModule.doc(firebaseDb, 'leaderboard', firebaseUser.uid);
    const existing = await fsModule.getDoc(docRef);
    if (existing.exists() && existing.data().score >= scoreVal) return true; // Already higher, still success
    const heightM = parseFloat((placedCount * BLOCK_HEIGHT / 100).toFixed(1));
    await fsModule.setDoc(docRef, {
      name: playerName,
      score: scoreVal,
      blocks: placedCount,
      height: heightM,
      peakCombo: peakComboVal,
      uid: firebaseUser.uid,
      updatedAt: fsModule.serverTimestamp(),
    });
    // Also reserve the name
    reserveName(playerName);
    return true;
  } catch (e) {
    console.error('Score submit error:', e);
    return false;
  }
}

async function checkNameAvailable(name) {
  if (!await loadFirebase()) return true;
  try {
    const fsModule = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
    const nameDoc = await fsModule.getDoc(fsModule.doc(firebaseDb, 'names', name.toLowerCase()));
    if (!nameDoc.exists()) return true;
    return nameDoc.data().uid === firebaseUser.uid;
  } catch (e) {
    return true; // Allow on error
  }
}

async function reserveName(name) {
  if (!await loadFirebase()) return;
  if (!firebaseUser) return;
  try {
    const fsModule = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
    // Release old name
    const oldName = localStorage.getItem('tiltTower_fbName');
    if (oldName && oldName.toLowerCase() !== name.toLowerCase()) {
      try { await fsModule.deleteDoc(fsModule.doc(firebaseDb, 'names', oldName.toLowerCase())); } catch(e) {}
    }
    await fsModule.setDoc(fsModule.doc(firebaseDb, 'names', name.toLowerCase()), {
      uid: firebaseUser.uid,
      originalCase: name,
    });
    localStorage.setItem('tiltTower_fbName', name);
  } catch (e) {
    console.error('Name reserve error:', e);
  }
}

async function fetchLeaderboard() {
  if (!await loadFirebase()) return null;
  try {
    const fsModule = await import('https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js');
    const q = fsModule.query(
      fsModule.collection(firebaseDb, 'leaderboard'),
      fsModule.orderBy('score', 'desc'),
      fsModule.limit(100)
    );
    const snapshot = await fsModule.getDocs(q);
    const entries = [];
    snapshot.forEach(doc => entries.push({ id: doc.id, ...doc.data() }));
    return entries;
  } catch (e) {
    console.error('Leaderboard fetch error:', e);
    return null;
  }
}

function openLeaderboard() {
  document.getElementById('leaderboardScreen').classList.remove('hidden');
  const table = document.getElementById('lbTable');
  const myScoreEl = document.getElementById('lbMyScore');
  myScoreEl.textContent = bestScoreVal > 0 ? `BEST: ${bestScoreVal}` : '---';
  table.innerHTML = '<div class="lb-loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>';

  fetchLeaderboard().then(entries => {
    if (!entries) {
      table.innerHTML = '<div class="lb-error">Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</div>';
      return;
    }
    if (entries.length === 0) {
      table.innerHTML = '<div class="lb-empty">„Åæ„Å†„Çπ„Ç≥„Ç¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
      return;
    }
    let myRank = -1;
    let html = '';
    entries.forEach((e, i) => {
      const rank = i + 1;
      const isMe = firebaseUser && e.uid === firebaseUser.uid;
      if (isMe) {
        myRank = rank;
        myScoreEl.textContent = `#${rank}  „Çπ„Ç≥„Ç¢ ${e.score}`;
      }
      let rankClass = '';
      let rankText = rank;
      if (rank === 1) { rankClass = 'gold'; rankText = 'ü•á'; }
      else if (rank === 2) { rankClass = 'silver'; rankText = 'ü•à'; }
      else if (rank === 3) { rankClass = 'bronze'; rankText = 'ü•â'; }
      html += `<div class="lb-row ${isMe ? 'me' : ''}">
        <span class="lb-rank ${rankClass}">${rankText}</span>
        <span class="lb-name">${escapeHtml(e.name)}</span>
        <span class="lb-score-col">${e.score}</span>
        <span class="lb-height-col">${e.height || 0}m</span>
      </div>`;
    });
    table.innerHTML = html;
  });
}

function closeLeaderboard() {
  document.getElementById('leaderboardScreen').classList.add('hidden');
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ===== Start =====
init();
</script>
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then((reg) => {
    reg.update();
    let refreshing = false;
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      if (!refreshing) { refreshing = true; location.reload(); }
    });
  });
}
</script>
</body>
</html>
